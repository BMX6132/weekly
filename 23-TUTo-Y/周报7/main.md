- [从源文件到可执行文件](#从源文件到可执行文件)
- [数据格式](#数据格式)
- [数据传输](#数据传输)
- [算术和逻辑操作](#算术和逻辑操作)
- [条件码](#条件码)
  - [访问条件码](#访问条件码)
  - [跳转指令及其编码](#跳转指令及其编码)
  - [条件传输指令](#条件传输指令)
- [寄存器使用惯例](#寄存器使用惯例)
- [数据结构](#数据结构)
- [函数返回值存放的寄存器](#函数返回值存放的寄存器)
- [函数传参](#函数传参)

# 从源文件到可执行文件

`main.c`->预处理->`main.i`->汇编->`main.s`->编译->`main.o`->链接->`main.out`

# 数据格式

| C语言声明     | 字节数(32位) | 字节数(64位) |
| :------------ | :----------: | :----------: |
| `char`        |      1       |      1       |
| `short`       |      2       |      2       |
| `int`         |      4       |      4       |
| `long`        |      4       |      8       |
| `long long`   |      8       |      8       |
| `void*`       |      4       |      8       |
| `float`       |      4       |      4       |
| `double`      |      8       |      8       |
| `long double` |      12      |      16      |

# 数据传输

| 指令   | 效果                     |
| ------ | ------------------------ |
| movb   | 传送字节                 |
| movw   | 传输字                   |
| movl   | 传输双字                 |
| movsbw | 符号扩展的字节传输到字   |
| movsbl | 符号扩展的字节传输到双字 |
| movswl | 符号扩展的字传输到双字   |
| movzbw | 零扩展的字节传输到字     |
| movzbl | 零扩展的字节传输到双字   |
| movzwl | 零扩展的字传输到双字     |

movs和movz都是将一个较小的数据复制到一个较大的数据位置，高位用符号位扩展(movs)或者零扩展(movz)

# 算术和逻辑操作

| 指令        | 效果       | 描述         |
| :---------- | :--------- | :----------- |
| leal S, D   | D ← &S     | 加载有效地址 |
| INC    D    | D ← D + 1  | 加1          |
| DEC    D    | D ← D - 1  | 减1          |
| NEG    D    | D ← -D     | 取补         |
| NOT    D    | D ← ~D     | 取反         |
| ADD    S, D | D ← D + S  | 加           |
| SUB    S, D | D ← D - S  | 减           |
| IMUL   S, D | D ← D * S  | 乘           |
| XOR    S, D | D ← D ^ S  | 异或         |
| OR     S, D | D ← D \| S | 或           |
| AND    S, D | D ← D & S  | 与           |
| SAL    k, D | D ← D << k | 左移         |
| SHL    k, D | D ← D << k | 左移(同SHL)  |
| SAR    k, D | D ← D >> k | 算术右移     |
| SHR    k, D | D ← D >> k | 逻辑右移     |

# 条件码

用于描述最近的算术或逻辑操作的属性
| 条件码 | 描述1    | 描述2                                                        |
| ------ | -------- | ------------------------------------------------------------ |
| CF     | 进位标志 | 最近的操作使最高位产生了进位，可以用来检测无符号操作数的溢出 |
| ZF     | 零标志   | 最近的操作得出的结果为0                                      |
| SF     | 符号标志 | 最近的操作得到的结果为负数                                   |
| OF     | 溢出标志 | 最近的操作导致一个补码溢出                                   |

CMP和SUB指令行为是一样的，但是CMP不改变目标寄存器的值
TEST和AND指令行为是一样的，但是TEST不改变目标寄存器的值

## 访问条件码

| 指令     | 同义名 | 效果               | 设置条件             |
| -------- | ------ | ------------------ | -------------------- |
| sete   D | setz   | D ← ZF             | 相等/零              |
| setne  D | setnz  | D ← ~ZF            | 不等/非零            |
| sets   D |        | D ← SF             | 负数                 |
| setns  D |        | D ← ~SF            | 非负数               |
| setg   D | setnle | D ← ~(SF^OF) & ~ZF | 大于(有符号>)        |
| setge  D | setnl  | D ← ~(SF^OF)       | 大于等于(有符号>=)   |
| setl   D | setnge | D ← SF^OF          | 小于(有符号<)        |
| setle  D | setng  | D ← (SF^OF) \| ZF  | 小于等于(有符号<=)   |
| seta   D | setnbe | D ← ~CF & ~ZF      | 超过(无符号>)        |
| setae  D | setnb  | D ← ~CF            | 超过或相等(无符号>=) |
| setb   D | setnae | D ← CF             | 低于(无符号<)        |
| setbe  D | setna  | D ← CF \| ZF       | 低于等于(无符号<=)   |

## 跳转指令及其编码

jmp指令是无条件跳转，它可以是直接跳转，也可以是间接跳转。其余所示跳转都是条件跳转，条件跳转只能是直接跳转。

- 跳转指令的编码有几种不同形式，最常用的有两种
1. 将目标指令的地址与紧跟在跳转指令后面的那条指令的地址的差作为编码，这些地址的偏移量可以为1，2或4个字节
2. 给出绝对地址，用四个字节(32位)直接指定目标

|指令|同义名|跳转条件|描述|
|----|----|----|----|
|jmp  Label   |     |1              |直接跳转|
|jmp  *Operand|     |1              |间接跳转|
|je   Label   |jz   |ZF             |相等/零|
|jne  Label   |jnz  |~ZF            |不相等/非零|
|js   Label   |     |SF             |负数|
|jns  Label   |     |~SF            |非负数|
|jg   Label   |jnle |~(SF^OF) & ~ZF |大于(有符号>)|
|jge  Label   |jnl  |~(SF^OF)       |大于或等于(有符号>=)|
|jl   Label   |jnge |SF ^ OF        |小于(有符号<)|
|jle  Label   |jng  |(SF^OF) \| ZF  |小于或等于(有符号<=)|
|ja   Label   |jnbe |~CF & ~ZF      |超过(无符号>)|
|jae  Label   |jnb  |~CF            |超过或相等(无符号>=)|
|jb   Label   |jnae |CF             |低于(无符号<)|
|jbe  Label   |jna  |CF \| ZF       |低于或相等(无符号<=)|

## 条件传输指令

大多数情况下，__数据的条件转移__ 的性能优于 __控制的条件转移__，原因在于，现代处理器使用了 __流水线__ 和 __预测执行__ 技术来提高性能。当执行条件跳转指令时，如果处理器预测错误，那么流水线可能需要被清空并重新填充，这会导致性能损失。而条件数据传输指令不会改变程序的控制流，因此不会导致流水线冲刷，通常可以提供更好的性能。
然而，这并不是绝对的。在某些情况下，例如当条件很少改变或者条件改变的代价很小时，条件跳转可能会更有效。此外，条件数据传输指令通常只能在寄存器之间传输数据，而不能直接访问内存。

|指令|同义名|跳转条件|描述|
|----|----|----|----|
|comve  S, R|cmovz  |ZF             |相等/零|
|cmovne S, R|cmovnz |~ZF            |不相等/非零|
|comvs  S, R|       |SF             |负数|
|comvns S, R|       |~SF            |非负数|
|comvg  S, R|cmovnle|~(SF^OF) & ~ZF |大于(有符号>)|
|comvge S, R|cmovnl |~(SF^OF)       |大于或等于(有符号>=)|
|comvl  S, R|cmovnge|SF ^ OF        |小于(有符号<)|
|comvle S, R|cmovng |(SF^OF) \| ZF  |小于或等于(有符号<=)|
|comva  S, R|cmovnbe|~CF & ~ZF      |超过(无符号>)|
|comvae S, R|cmovnb |~CF            |超过或相等(无符号>=)|
|comvb  S, R|cmovnae|CF             |低于(无符号<)|
|comvbe S, R|cmovna |CF \| ZF       |低于或相等(无符号<=)|

传统的编译器通过判断是否满足条件后进行计算
基于数据条件传输的代码会先计算，然后根据条件去改变结果

# 寄存器使用惯例

1. __32位 System V ABI__:
    - __参数传递__: 所有参数都通过堆栈传递, 从右向左压入堆栈
    - __返回值__: 整数和指针返回值通过 `EAX` 寄存器传递，浮点返回值通过 `ST0` 寄存器（浮点堆栈的顶部）传递
    - __调用者保存__: 调用者需要在调用函数前保存 `EAX`, `ECX`, `EDX` 寄存器的值, 被调用者可以改变这些寄存器的值
    - __被调用者保存__: 被调用者需要保存 `EBP`, `ESP`, `EBX`, `ESI`, `EDI` 寄存器的值, 被调用者返回时应当还原这些寄存器的值

2. __64位 System V ABI__:
    - __参数传递__: 前六个整数或指针参数通过寄存器 `RDI`, `RSI`, `RDX`, `RCX`, `R8` 和 `R9` 传递, 前八个浮点参数通过 `XMM0` 到 `XMM7` 传递
    - __返回值__: 整数和指针返回值通过 `RAX` 寄存器传递，浮点返回值通过 XMM0 寄存器传递
    - __调用者保存__: 调用者需要在调用函数前保存 `RAX`, `RCX`, `RDX`, `RSI`, `RDI`, `R8`, `R9`, `R10`, `R11` 以及所有 `XMM` 寄存器的值, 被调用者可以改变这些寄存器的值
    - __被调用者保存__: 被调用者需要保存 `RBX`, `RBP`, `RSP`, `R12`, `R13`, `R14`, `R15` 以及所有 `XMM` 寄存器的值, 被调用者返回时应当还原这些寄存器的值

# 数据结构

struct结构体的一般规则:

1. __32位系统__
    - 结构体的总大小为其 __最大成员__ 的大小的倍数。如果不是，则会在结构体的 __末尾__ 添加填充字节
    - 结构体的每个成员相对于结构体 __开始__ 的偏移量是 __该成员__ 大小的倍数。如果不是，则会在该成员 __前__ 添加填充字节
2. __64位系统__
    - 结构体的总大小为其 __最大成员__ 的大小的倍数。如果不是，则会在结构体的 __末尾__ 添加填充字节
    - 结构体的每个成员相对于结构体 __开始__ 的偏移量是 __该成员__ 大小的倍数。如果不是，则会在该成员 __前__ 添加填充字节

# 函数返回值存放的寄存器

    64位:rax
    32位:eax

# 函数传参

    32位
    eax:系统调用号
    ebx:第一个参数
    ecx:第二个参数
    edx:第三个参数
    esx:第四个参数
    edi:第五个参数

    64位
    rax:系统调用号
    rdi:第一个参数
    rsi:第二个参数
    rdx:第三个参数
    rcx:第四个参数
    r8 :第五个参数
    r9 :第六个参数

