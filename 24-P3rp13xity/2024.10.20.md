# 完成事项
1. BUU第一页密码题刷完了，后来把WP也给补上了
2. 古典密码
3. Python看了一点
4. 学了下乘法逆元

# 下周待做事项
1. 继续看Python
2. 学数论
3. 继续肝BUU

# 本周学习的知识分享
## BUU WP
### 大帝的密码武器
根据文件名给下载的文件添加后缀（.zip）即可打开文件,将文件中的FRPHEVGL进行枚举解密找到security，其位移量为13，用该位移量加密ComeChina得到flag

flag{PbzrPuvan}

### rsarsa
```plain
import gmpy2 as gp
import binascii
p=gp.mpz(9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483)
q=gp.mpz(11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407)
e=gp.mpz(65537)
c=gp.mpz(83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034)
n=p*q
phi=(p-1)*(q-1)
d=gp.invert(e,phi)
m=pow(c,d,n)
print(binascii.unhexlify(hex(m)[2:]))
```

执行得到b'\x12\x05\x8eC\xd9\xe0\xc2%Y\xc1\x97t'，发现不是正确的flag，上网查找WP，发现不需要将m转化为二进制数据表现形式，即最后一行代码改为print(m),得到flag

flag{5577446633554466577768879988}

### 异性相吸
用010 editor 打开文件读取文件内容的二进制数值![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1729174451381-b3d5b7ea-e62b-4ab0-8b8e-0f1ec105221e.png)

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1729174451377-466f1f0c-92d7-4c1e-be13-53c79c533254.png)

将两份二进制数进行异或运算，得到的结果转成字符，得到flag

flag{ea1bc0988992276b7f95b54a7435e89e}

### RSA
将文件后缀改为.txt即可打开文件进行访问

将pub文件中的内容进行公钥解密得到e,n

![](https://cdn.nlark.com/yuque/0/2024/png/49639454/1729174451382-e31484b7-3344-4d4e-a716-e0c93d449a0c.png)

分解n,得到p,q

```plain
import gmpy2
import rsa

e = 65537
n = 86934482296048119190666062003494800588905656017203025617216654058378322103517
p = 285960468890451637935629440372639283459
q = 304008741604601924494328155975272418463
phi = (q - 1) * (p - 1)
d = gmpy2.invert(e, phi)
key = rsa.PrivateKey(n, e, int(d), p, q)
with open("d:\\Users\\lenovo\Downloads\\0eaf8d6c-3fe5-4549-9e81-94ac42535e7b\\flag.txt", "rb+") as f:
    f = f.read()
    print(rsa.decrypt(f, key))
```

flag{decrypt_256}

### RSAROLL
```plain
import gmpy2 as gp
import binascii
p=gp.mpz(18443)
q=gp.mpz(49891)
e=gp.mpz(19)
roll=["704796792","752211152","274704164","18414022","368270835","483295235","263072905","459788476","483295235","459788476","663551792","475206804","459788476","428313374","475206804","459788476","425392137","704796792","458265677","341524652","483295235","534149509","425392137","428313374","425392137","341524652","458265677","263072905","483295235","828509797","341524652","425392137","475206804","428313374","483295235","475206804","459788476","306220148"]
txt=''
for i in roll:
    c = gp.mpz(int(i))
    n = p * q
    phi = (p - 1) * (q - 1)
    d = gp.invert(e, phi)
    m = pow(c, d, n)
    txt+=str(binascii.unhexlify(hex(m)[2:]))#求出每一行的相应明文
b=["b","'"]
new=''
for i in range(len(txt)):
    if txt[i] not in b:
        new+=str(txt[i])#删除b和'
print(new)
```

flag{13212je2ue28fy71w8u87y31r78eu1e2}

## 古典密码
### 特点
1. 计算强度小
2. 出现在 DES 之前
3. 数据安全基于算法的保密。这和现代密码有很大的差距，只要知道加密方法，就能轻易的获取明文。现代的密码基于秘钥的加密，算法都是公开的，而且公开的密码算法安全性更高，能被更多人评论和使用，加强漏洞的修补。
4. 以字母表为主要加密对象。古典密码大多数是对有意义的文字进行加密，而现代密码是对比特序列进行加密。这也是现代密码和古典密码的区别，而且古典密码的分析方法也是用字母频率分析表来破解的。
5. 替换和置换技术
6. 密码分析方法基于字母与字母组合的频率特性以及明文的可读性
7. 分析方法：统计分析法、明文-密文分析法、穷举分析法、重合指数法

### 培根密码
加密的过程首先将要加密的内容根据加密表里的内容进行替换，

如a用AAAAA替换，b用AAAAB替换。

替换完之后，我们可以把A和B当作两个不同的特征（如大写/小写，正体/斜体）带入到一个无关的句子中，

这就得到了我们加密后的结果。

_<u>本质上是将二进制信息通过样式的区别，加在了正常书写之上。</u>_

_<u>培根密码所包含的信息可以和用于承载其的文章完全无关。</u>_

### 普莱费尔密码Playfair Cipher
基本加密规则：

准备密钥方阵：首先选择一个密钥词（通常去除重复字母），将其字母按顺序填入5x5的方阵中，剩余的格子按字母表顺序填充，未使用的字母继续填充，通常将字母“I”和“J”视为相同，以适应25个格子。

准备明文：将明文分为字母对，如果有一个字母单独存在，则添加一个额外的字母（如'X'或'Q'）使其成对。如果一对字母相同，则插入一个填充字母如'X'，例如“HELLO”变为“HE LX LO”。

加密规则：对每对字母应用以下规则：

如果字母对在同一行：对每个字母，用其右侧的字母替换（如果是行尾，则换到行首）。

如果字母对在同一列：对每个字母，用其下方的字母替换（如果是列底，则换到列顶）。

如果字母对在不同行不同列：字母对在方阵中形成一个矩形，用同行对角的字母进行替换，即保持行不变，交换列。

_<u>它有一些不太明显的特征：密文的字母数一定是偶数，任意两个同组的字母都不会相同，如果出现这种字符必定是乱码或虚码。</u>_

### <font style="color:rgb(34, 34, 34);">希尔密码Hill Cipher</font>
希尔密码是一种基于线性代数的多表替换密码。

[希尔密码详解](https://blog.csdn.net/lcn463365355/article/details/130208962)

### 周期置换密码
加密：将明文P按照固定常长度m分组，然后对每组的字符串按照（1，2，3，4…m）的置换重新排列位置从而得到密文。

解密的时候对密文c按照长度m分组，按照密钥的<font style="color:#2F8EF4;">逆置换</font>把每组重新排列，从而得到明文P。

> <font style="color:#2F8EF4;">逆置换</font><font style="color:#81BBF8;">：给定一个排列 p，它的逆置换（inverse permutation）是一个排列 invp，满足 invp[p[i]] = i 和 p[invp[i]] = i 对所有 i 成立。</font>
>



# 本周学习总结
边做题边写WP！！！否则会和我一样把第一页又全做了一遍：）（血的教训）

古典密码好多，有一些基本上大差不差，只是密码表变换了下，或者一些是几个密码的组合运用



