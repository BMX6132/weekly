# 0408-0414总结

## 0408

### [羊城杯 2021]BabySmc

直接动调解SMC，发现为变表不可见字符Base64，然后异或变可见字符得密文。

“1”和“4”得作用相当于原表“=”，直接strip即可。

```python
res="H>oQn6aqLr{DH6odhdm0dMe`MBo?lRglHtGPOdobDlknejmGI|ghDb<"
key=[0xA6,0xA3,0xA9,0xAC]
flag=[]
for i in range(len(res)):
    flag.append(ord(res[i])^key[i%len(key)])
table=[0xE4,0xC4,0xE7,0xC7,0xE6,0xC6,0xE1,0xC1,0xE0,0xC0,0xE3,0xC3,0xE2,0xC2,0xED,0xCD,0xEC,0xCC,0xEF,0xCF,0xEE,0xCE,0xE9,0xC9,0xE8,0xC8,0xEB,0xCB,0xEA,0xCA,0xF5,0xD5,0xF4,0xD4,0xF7,0xD7,0xF6,0xD6,0xF1,0xD1,0xF0,0xD0,0xF3,0xD3,0xF2,0xD2,0xFD,0xDD,0xFC,0xDC,0xFF,0xDF,0x95,0x9C,0x9D,0x92,0x93,0x90,0x91,0x96,0x97,0x94,0x8A,0x8E]
result=b''
for i in flag:
    result+=bytes('{:0>6}'.format(bin(table.index(i)).replace("0b","")).encode())
for i in range(0,len(result),8):
    print(chr(int(result[i:i+8],2)),end='')
```

当然拿IDAPython也能做：

```python
import idc,ida_bytes
start=0x140001085
end=0x140001D00
def change_byte(uint8):
    return (((uint8&7)<<5)|(uint8>>3))^0x5a #ROR3
size=end-start+1
b=idc.get_bytes(start,size)
b2=bytes([change_byte(x) for x in b])
ida_bytes.patch_bytes(start,b2)
```

### [HGAME 2023 week3]kunmusic

找资源节“data”，发现异或后解析：

```c#
Activator.CreateInstance(Assembly.Load(data).GetType("WinFormsLibrary1.Class1"), new object[]{
	Program.form1
});
Application.Run(Program.form1);
```

直接dump出来：

```python
f1=open("data","rb")
arr1=f1.read()
arr2=[0]*len(arr1)
for i in range(len(arr1)):
    arr2[i]=arr1[i]^104
f2=open("output","wb")
f2.write(bytes(arr2))
```

output是个I386的.NET，再分析为z3：

```python
from z3 import *
key=[132,47,180,7,216,45,68,6,39,246,124,2,243,137,58,172,53,200,99,91,83,13,171,80,108,235,179,58,176,28,216,36,11,80,39,162,97,58,236,130,123,176,24,212,56,89,72]
s=Solver()
num=[BitVec('num%d'%i,9)for i in range(13)]
s.add(num[0]+52296+num[1]-26211+num[2]-11754+(num[3]^41236)+num[4]*63747+num[5]-52714+num[6]-10512+num[7]*12972+num[8]+45505+num[9]-21713+num[10]-59122+num[11]-12840+(num[12]^21087)==12702282)
s.add(num[0]-25228+(num[1]^20699)+(num[2]^8158)+num[3]-65307+num[4]*30701+num[5]*47555+num[6]-2557+(num[7]^49055)+num[8]-7992+(num[9]^57465)+(num[10]^57426)+num[11]+13299+num[12]-50966==9946829)
s.add(num[0]-64801+num[1]-60698+num[2]-40853+num[3]-54907+num[4]+29882+(num[5]^13574)+(num[6]^21310)+num[7]+47366+num[8]+41784+(num[9]^53690)+num[10]*58436+num[11]*15590+num[12]+58225==2372055)
s.add(num[0]+61538+num[1]-17121+num[2]-58124+num[3]+8186+num[4]+21253+num[5]-38524+num[6]-48323+num[7]-20556+num[8]*56056+num[9]+18568+num[10]+12995+(num[11]^39260)+num[12]+25329==6732474)
s.add(num[0]-42567+num[1]-17743+num[2]*47827+num[3]-10246+(num[4]^16284)+num[5]+39390+num[6]*11803+num[7]*60332+(num[8]^18491)+(num[9]^4795)+num[10]-25636+num[11]-16780+num[12]-62345==14020739)
s.add(num[0]-10968+num[1]-31780+(num[2]^31857)+num[3]-61983+num[4]*31048+num[5]*20189+num[6]+12337+num[7]*25945+(num[8]^7064)+num[9]-25369+num[10]-54893+num[11]*59949+(num[12]^12441)==14434062)
s.add(num[0]+16689+num[1]-10279+num[2]-32918+num[3]-57155+num[4]*26571+num[5]*15086+(num[6]^22986)+(num[7]^23349)+(num[8]^16381)+(num[9]^23173)+num[10]-40224+num[11]+31751+num[12]*8421==7433598)
s.add(num[0]+28740+num[1]-64696+num[2]+60470+num[3]-14752+(num[4]^1287)+(num[5]^35272)+num[6]+49467+num[7]-33788+num[8]+20606+(num[9]^44874)+num[10]*19764+num[11]+48342+num[12]*56511==7989404)
s.add((num[0]^28978)+num[1]+23120+num[2]+22802+num[3]*31533+(num[4]^39287)+num[5]-48576+(num[6]^28542)+num[7]-43265+num[8]+22365+num[9]+61108+num[10]*2823+num[11]-30343+num[12]+14780==3504803)
s.add(num[0]*22466+(num[1]^55999)+num[2]-53658+(num[3]^47160)+(num[4]^12511)+num[5]*59807+num[6]+46242+num[7]+3052+(num[8]^25279)+num[9]+30202+num[10]*22698+num[11]+33480+(num[12]^16757)==11003580)
s.add(num[0]*57492+(num[1]^13421)+num[2]-13941+(num[3]^48092)+num[4]*38310+num[5]+9884+num[6]-45500+num[7]-19233+num[8]+58274+num[9]+36175+(num[10]^18568)+num[11]*49694+(num[12]^9473)==25546210)
s.add(num[0]-23355+num[1]*50164+(num[2]^34618)+num[3]+52703+num[4]+36245+num[5]*46648+(num[6]^4858)+(num[7]^41846)+num[8]*27122+(num[9]^42058)+num[10]*15676+num[11]-31863+num[12]+62510==11333836)
s.add(num[0]*30523+(num[1]^7990)+num[2]+39058+num[3]*57549+(num[4]^53440)+num[5]*4275+num[6]-48863+(num[7]^55436)+(num[8]^2624)+(num[9]^13652)+num[10]+62231+num[11]+19456+num[12]-13195==13863722)
assert s.check()==sat
res=s.model()
tmp=[0]*13
for i in range(0,13):
    tmp[i]=res[num[i]].as_long()
print(tmp)
for i in range(len(key)):
    print(chr((key[i]^tmp[i%len(tmp)])&0x7f),end='')
```

垃圾z3多解不能全报，而且每个版本的z3_solver报的都不一样...BitVec的位深改为9才报正确的...

### [HGAME 2023 week4]vm

史上最简单虚拟机...

根据提示恢复结构体，得一系列：

```c
void __fastcall sub_1400018A0(vm *a1)
{
  int v1; // eax

  if ( LOBYTE(a1->zf) )
    v1 = opcodes[a1->ip + 1];
  else
    v1 = a1->ip + 2;
  a1->ip = v1;
}
void __fastcall op_je(vm *a1)
{
  int v1; // eax

  if ( LOBYTE(a1->zf) )
    v1 = a1->ip + 2;
  else
    v1 = opcodes[a1->ip + 1];
  a1->ip = v1;
}
void __fastcall op_jmp(vm *a1)
{
  a1->ip = opcodes[a1->ip + 1];
}
void __fastcall op_cmp(vm *a1)
{
  if ( a1->reg[0] == a1->reg[1] )
    LOBYTE(a1->zf) = 0;
  if ( a1->reg[0] != a1->reg[1] )
    LOBYTE(a1->zf) = 1;
  ++a1->ip;
}
void __fastcall sub_1400014D0(vm *a1)
{
  switch ( opcodes[a1->ip + 1] )
  {
    case 0u:
      a1->reg[opcodes[a1->ip + 2]] += a1->reg[opcodes[a1->ip + 3]];
      break;
    case 1u:
      a1->reg[opcodes[a1->ip + 2]] -= a1->reg[opcodes[a1->ip + 3]];
      break;
    case 2u:
      a1->reg[opcodes[a1->ip + 2]] *= a1->reg[opcodes[a1->ip + 3]];
      break;
    case 3u:
      a1->reg[opcodes[a1->ip + 2]] ^= a1->reg[opcodes[a1->ip + 3]];
      break;
    case 4u:
      a1->reg[opcodes[a1->ip + 2]] <<= a1->reg[opcodes[a1->ip + 3]];
      a1->reg[opcodes[a1->ip + 2]] &= 0xFF00u;
      break;
    case 5u:
      a1->reg[opcodes[a1->ip + 2]] >>= a1->reg[opcodes[a1->ip + 3]];
      break;
    default:
      break;
  }
  a1->ip += 4;
}
void __fastcall op_pop(vm *a1)
{
  unsigned __int8 v1; // [rsp+0h] [rbp-18h]

  v1 = opcodes[a1->ip + 1];
  if ( v1 )
  {
    switch ( v1 )
    {
      case 1u:
        a1->reg[1] = stack[a1->sp--];
        break;
      case 2u:
        a1->reg[2] = stack[a1->sp--];
        break;
      case 3u:
        a1->reg[3] = stack[a1->sp--];
        break;
    }
  }
  else
  {
    a1->reg[0] = stack[a1->sp--];
  }
  a1->ip += 2;
}
void __fastcall op_push(vm *a1)
{
  unsigned __int8 v1; // [rsp+0h] [rbp-18h]

  v1 = opcodes[a1->ip + 1];
  if ( v1 )
  {
    switch ( v1 )
    {
      case 1u:
        stack[++a1->sp] = a1->reg[0];
        break;
      case 2u:
        stack[++a1->sp] = a1->reg[2];
        break;
      case 3u:
        stack[++a1->sp] = a1->reg[3];
        break;
    }
  }
  else
  {
    stack[++a1->sp] = a1->reg[0];
  }
  a1->ip += 2;
}
void __fastcall op_mov(vm *a1)
{
  unsigned __int8 v1; // [rsp+0h] [rbp-18h]

  v1 = opcodes[a1->ip + 1];
  if ( v1 )
  {
    switch ( v1 )
    {
      case 1u:
        inputStr[a1->reg[2]] = a1->reg[0];
        break;
      case 2u:
        a1->reg[opcodes[a1->ip + 2]] = a1->reg[opcodes[a1->ip + 3]];
        break;
      case 3u:
        a1->reg[opcodes[a1->ip + 2]] = opcodes[a1->ip + 3];
        break;
    }
  }
  else
  {
    a1->reg[0] = inputStr[a1->reg[2]];
  }
  a1->ip += 4;
}
void __fastcall dispatcher(vm *a1)
{
  switch ( opcodes[a1->ip] )
  {
    case 0u:
      op_mov(a1);
      break;
    case 1u:
      op_push(a1);
      break;
    case 2u:
      op_pop(a1);
      break;
    case 3u:
      op_cal(a1);
      break;
    case 4u:
      op_cmp(a1);
      break;
    case 5u:
      op_jmp(a1);
      break;
    case 6u:
      op_je(a1);
      break;
    case 7u:
      op_jne(a1);
      break;
    default:
      return;
  }
}
__int64 __fastcall vm_start(vm *a1)
{
  while ( opcodes[a1->ip] != 255 )
    dispatcher(a1);
  return LOBYTE(a1->zf);
}
```

从网上wp嗦个脚本跑：

```python
opcode = [0x00, 0x03, 0x02, 0x00, 0x03, 0x00, 0x02, 0x03, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x03, 0x02, 0x32,
          0x03, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00,
          0x01, 0x00, 0x00, 0x03, 0x02, 0x64, 0x03, 0x00, 0x02, 0x03,
          0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x01, 0x00, 0x00, 0x03,
          0x00, 0x08, 0x00, 0x02, 0x02, 0x01, 0x03, 0x04, 0x01, 0x00,
          0x03, 0x05, 0x02, 0x00, 0x03, 0x00, 0x01, 0x02, 0x00, 0x02,
          0x00, 0x01, 0x01, 0x00, 0x00, 0x03, 0x00, 0x01, 0x03, 0x00,
          0x03, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x01, 0x28,
          0x04, 0x06, 0x5F, 0x05, 0x00, 0x00, 0x03, 0x03, 0x00, 0x02,
          0x01, 0x00, 0x03, 0x02, 0x96, 0x03, 0x00, 0x02, 0x03, 0x00,
          0x00, 0x00, 0x00, 0x04, 0x07, 0x88, 0x00, 0x03, 0x00, 0x01,
          0x03, 0x00, 0x03, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03,
          0x01, 0x28, 0x04, 0x07, 0x63, 0xFF, 0xFF]
input1 = []
i = 0
while opcode[i] != 0xFF:
    match opcode[i]:
        case 0x00:
            print(f'{i}', end=' ')
            o = i + 1
            if opcode[o]:
                match opcode[o]:
                    case 0x01:
                        print("mov input[reg[2]], reg[0]")
                    case 0x02:
                        print("mov reg[%d], reg[%d]" % (opcode[i+2],opcode[i+3]))
                    case 0x03:
                        print("mov reg[%d], %d" % (opcode[i+2], opcode[i+3]))
            else:
                print("mov reg[0], input[reg[2]]")
            i += 4
        case 0x01:
            print(f'{i}', end=' ')
            o = i + 1
            if opcode[o]:
                match opcode[o]:
                    case 0x01:
                        print("push reg[0]")
                    case 0x02:
                        print("push reg[2]")
                    case 0x03:
                        print("push reg[3]")
            else:
                print("push reg[0]")
            i += 2
        case 0x02:
            print(f'{i}', end=' ')
            o = i + 1
            if opcode[o]:
                match opcode[o]:
                    case 0x01:
                        print("pop reg[1]")
                    case 0x02:
                        print("pop reg[2]")
                    case 0x03:
                        print("pop reg[3]")
            else:
                print("pop reg[0]")
            i += 2
        case 0x03:
            print(f'{i}', end=' ')
            o = i + 1
            match opcode[o]:
                case 0:
                    print("add reg[%d],reg[%d]" % (opcode[i + 2], opcode[i + 3]))
                case 1:
                    print("sup reg[%d],reg[%d]" % (opcode[i + 2], opcode[i + 3]))
                case 2:
                    print("mul reg[%d],reg[%d]" % (opcode[i + 2], opcode[i + 3]))
                case 3:
                    print("xor reg[%d],reg[%d]" % (opcode[i + 2], opcode[i + 3]))
                case 4:
                    print("shl reg[%d],reg[%d]" % (opcode[i + 2], opcode[i + 3]))
                case 5:
                    print("shr reg[%d],reg[%d]" % (opcode[i + 2], opcode[i + 3]))
            i += 4
        case 0x04:
            print(f'{i} cmp reg[0], reg[1]')
            i += 1
        case 0x05:
            print(f'{i} jmp %d ' % (opcode[i+1]))
            i += 2
        case 0x06:
            print(f'{i} je %d ' % (opcode[i+1]))
            i += 2
        case 0x07:
            print(f'{i} jne %d ' % (opcode[i+1]))
            i += 2
```

结果这样：

```
0 mov reg[2], 0
4 add reg[2],reg[3]
8 mov reg[0], input[reg[2]]
12 mov reg[1], reg[0]
16 mov reg[2], 50
20 add reg[2],reg[3]
24 mov reg[0], input[reg[2]]
28 add reg[1],reg[0]
32 mov reg[2], 100
36 add reg[2],reg[3]
40 mov reg[0], input[reg[2]]
44 xor reg[1],reg[0]
48 mov reg[0], 8
52 mov reg[2], reg[1]
56 shl reg[1],reg[0]
60 shr reg[2],reg[0]
64 add reg[1],reg[2]
68 mov reg[0], reg[1]
72 push reg[0]
74 mov reg[0], 1
78 add reg[3],reg[0]
82 mov reg[0], reg[3]
86 mov reg[1], 40
90 cmp reg[0], reg[1]
91 je 95 
93 jmp 0 
95 mov reg[3], 0
99 pop reg[1]
101 mov reg[2], 150
105 add reg[2],reg[3]
109 mov reg[0], input[reg[2]]
113 cmp reg[0], reg[1]
114 jne 136 
116 mov reg[0], 1
120 add reg[3],reg[0]
124 mov reg[0], reg[3]
128 mov reg[1], 40
132 cmp reg[0], reg[1]
133 jne 99 
```

然后`inputStr`布局这样：

```
.data:0000000140005040                             ; _DWORD inputStr[200]
.data:0000000140005040 00 00 00 00 00 00 00 00     inputStr        dd 32h dup(0)           ; DATA XREF: op_mov+55↑o
.data:0000000140005040 00 00 00 00 00 00 00 00                                             ; op_mov+90↑o
.data:0000000140005040 00 00 00 00 00 00 00 00…                                            ; main+75↑o
.data:0000000140005108 9B 00 00 00 A8 00 00 00…                    dd 155, 168, 2, 188, 172, 156, 206, 250, 2, 185, 255, 58
.data:0000000140005138 74 00 00 00 48 00 00 00…                    dd 116, 72, 25, 105, 232, 3, 203, 201, 255, 252, 128, 214
.data:0000000140005168 8D 00 00 00 D7 00 00 00…                    dd 141, 215, 114, 0, 167, 29, 61, 153, 136, 153, 191, 232
.data:0000000140005198 96 00 00 00 2E 00 00 00…                    dd 150, 46, 93, 87, 10 dup(0)
.data:00000001400051D0 C9 00 00 00 A9 00 00 00…                    dd 201, 169, 189, 139, 23, 194, 110, 248, 245, 110, 2 dup(99)
.data:0000000140005200 D5 00 00 00 46 00 00 00…                    dd 213, 70, 93, 22, 152, 56, 48, 115, 56, 193, 94, 237
.data:0000000140005230 B0 00 00 00 29 00 00 00…                    dd 176, 41, 90, 24, 64, 167, 253, 10, 30, 120, 139, 98
.data:0000000140005260 DB 00 00 00 0F 00 00 00…                    dd 219, 15, 143, 156, 10 dup(0)
.data:0000000140005298 00 48 00 00 00 F1 00 00…                    dd 18432, 61696, 16384, 8448, 13569, 25600, 30721, 63744
.data:00000001400052B8 01 18 00 00 00 52 00 00…                    dd 6145, 20992, 9472, 23809, 18176, 64768, 26881, 23552
.data:00000001400052D8 01 AF 00 00 00 B2 00 00…                    dd 44801, 45568, 60417, 20993, 20225, 6657, 20480, 34049
.data:00000001400052F8 00 CD 00 00 00 23 00 00…                    dd 52480, 8960, 63488, 3072, 52992, 15617, 17665, 33280
.data:0000000140005318 01 D2 00 00 01 29 00 00…                    dd 53761, 10497, 54529, 1537, 41473, 56832, 42497, 51713
.data:0000000140005338 00 00 00 00 00 00 00 00…                    dd 10 dup(0)
```

`input[0]`是读入，`input[50+i]`是`a1`，`input[100+i]`是`a2`，`input[150+i]`是`a3`。

大致看一下，写exp：

```python
a1=[0x0000009B,0x000000A8,0x00000002,0x000000BC,0x000000AC,0x0000009C,0x000000CE,0x000000FA,0x00000002,0x000000B9,0x000000FF,0x0000003A,0x00000074,0x00000048,0x00000019,0x00000069,0x000000E8,0x00000003,0x000000CB,0x000000C9,0x000000FF,0x000000FC,0x00000080,0x000000D6,0x0000008D,0x000000D7,0x00000072,0x00000000,0x000000A7,0x0000001D,0x0000003D,0x00000099,0x00000088,0x00000099,0x000000BF,0x000000E8,0x00000096,0x0000002E,0x0000005D,0x00000057]
a2=[0x000000C9,0x000000A9,0x000000BD,0x0000008B,0x00000017,0x000000C2,0x0000006E,0x000000F8,0x000000F5,0x0000006E,0x00000063,0x00000063,0x000000D5,0x00000046,0x0000005D,0x00000016,0x00000098,0x00000038,0x00000030,0x00000073,0x00000038,0x000000C1,0x0000005E,0x000000ED,0x000000B0,0x00000029,0x0000005A,0x00000018,0x00000040,0x000000A7,0x000000FD,0x0000000A,0x0000001E,0x00000078,0x0000008B,0x00000062,0x000000DB,0x0000000F,0x0000008F,0x0000009C]
a3=[0x00004800,0x0000F100,0x00004000,0x00002100,0x00003501,0x00006400,0x00007801,0x0000F900,0x00001801,0x00005200,0x00002500,0x00005D01,0x00004700,0x0000FD00,0x00006901,0x00005C00,0x0000AF01,0x0000B200,0x0000EC01,0x00005201,0x00004F01,0x00001A01,0x00005000,0x00008501,0x0000CD00,0x00002300,0x0000F800,0x00000C00,0x0000CF00,0x00003D01,0x00004501,0x00008200,0x0000D201,0x00002901,0x0000D501,0x00000601,0x0000A201,0x0000DE00,0x0000A601,0x0000CA01]
a3=a3[::-1]
flag=[0]*40
for i in range(40):
    flag[i]=(a3[i]>>8)+(a3[i]<<8)
    flag[i]^=a2[i]
    flag[i]-=a1[i]
for i in range(40):
    print(chr(flag[i]&0xFF),end='')
```

### [HDCTF 2023]买了些什么呢

01背包板子题，但下标0或1开始比较抽象：

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
int weight[41]={0,2,5,10,9,3,6,2,2,6,8,2,3,3,2,9,8,2,10,8,6,4,3,4,2,4,8,3,8,4,10,7,1,9,1,5,7,1,1,7,4},value[41]={0,8,1,5,9,5,6,8,2,3,7,5,4,3,7,6,7,9,3,10,5,2,4,5,2,9,5,8,10,2,9,6,3,7,3,9,6,10,1,2,9},dp[41][51];
bool rec[41][51];
vector<int>vec;
int main(void){
    for(register int i=1;i<=40;i++)
        for(register int j=1;j<=50;j++)
            if(j<weight[i])
                dp[i][j]=dp[i-1][j];
            else if(value[i]+dp[i-1][j-weight[i]]>dp[i-1][j])
                dp[i][j]=value[i]+dp[i-1][j-weight[i]],
                rec[i][j]=true;
            else
                dp[i][j]=dp[i-1][j];
    for(register int i=40,j=50;i>0;i--)
        if(rec[i][j]==true){
            vec.push_back(i);
            j-=weight[i];
        };
    sort(vec.begin(),vec.end());
    for(vector<int>::iterator it=vec.begin();it!=vec.end();it++)
        printf("%d ",(*it)-1);
    return 0;
};
```

## 0409

### [第五空间 2021]StrangeLanguage

pyinstxtractor+pycdc正常解包，发现逻辑在“brainfuck”里，找到.pyd文件即.dll文件丢IDA，找到BrainFuck代码，用这个在Linux下转Python：https://github.com/rdebath/Brainfuck。

生成800多行Python代码，尝试找网上wp。

盯着中间一坨数据，猜测加密方法可得flag：

```python
res=[83,15,90,84,80,85,3,2,0,7,86,7,7,91,9,0,80,5,2,3,93,92,80,81,82,84,90,95,2,87,7,52,0]
for i in range(31,-1,-1):
    res[i]^=res[i+1]
for i in range(len(res)):
    print(chr(res[i]),end='')
```

### [长城杯 2021 院校组]Just_cmp-re

抽象题别做。

```python
s1="flag{********************************}"
key=[0x00,0x00,0x00,0x00,0x00,0x37,0x07,0x0A,0x37,0x0A,0x08,0x0A,0x06,0x06,0x0B,0x38,0x07,0x0A,0x3B,0x08,0x38,0x0E,0x0F,0x3B,0x3A,0x0A,0x0B,0x06,0x09,0x07,0x3B,0x37,0x0D,0x0F,0x07,0x38,0x0F,0x00]
for i in range(len(s1)):
    print(chr(ord(s1[i])+key[i]),end='')
```

### [CISCN 2021初赛]babybc

5x5线性规划，z3做：

```python
from z3 import *
import hashlib
map=[[None]*5,
     [None]*5,
     [None]*5,
     [None]*5,
     [None]*5]
row=[[0x00,0x00,0x00,0x01],
     [0x01,0x00,0x00,0x00],
     [0x02,0x00,0x00,0x01],
     [0x00,0x00,0x00,0x00],
     [0x01,0x00,0x01,0x00]]
col=[[0x00,0x00,0x02,0x00,0x02],
     [0x00,0x00,0x00,0x00,0x00],
     [0x00,0x00,0x00,0x01,0x00],
     [0x00,0x01,0x00,0x00,0x01]]
for i in range(5):
    for j in range(5):
        map[i][j]=Int('map%d%d'%(i,j))
s=Solver()
s.add(map[2][2]==0x04)
s.add(map[3][3]==0x03)
for i in range(5):
    for j in range(5):
        s.add(map[i][j]>=1)
        s.add(map[i][j]<=5)
for i in range(5):
    for j in range(5):
        for k in range(j+1,5):
            s.add(map[i][j]!=map[i][k])
for i in range(5):
    for j in range(5):
        for k in range(j+1,5):
            s.add(map[j][i]!=map[k][i])
for i in range(5):
    for j in range(4):
        if row[i][j]==0x01:
            s.add(map[i][j]>map[i][j+1])
        elif row[i][j]==0x02:
            s.add(map[i][j]<map[i][j+1])
for i in range(4):
    for j in range(5):
        if col[i][j]==0x01:
            s.add(map[i][j]<map[i+1][j])
        elif col[i][j]==0x02:
            s.add(map[i][j]>map[i+1][j])
if s.check()==sat:
    res=s.model()
    s=''
    for i in range(5):
        for j in range(5):
            if ((i==2)and(j==2))or((i==3)and(j==3)):
                s+='0'
            else:
                s+=str(res[map[i][j]].as_long())
    print('CISCN{%s}'%(hashlib.md5(s.encode()).hexdigest()))
```

### [GWCTF 2019]babyvm

简单虚拟机，先识别指令集：

```c
void __fastcall op_cal(__int64 a1)
{
  *(_DWORD *)a1 = *(_DWORD *)(a1 + 8) + 2 * *(_DWORD *)(a1 + 4) + 3 * *(_DWORD *)a1;
  ++*(_QWORD *)(a1 + 16);
}
void __fastcall op_swp(int *a1)
{
  int v1; // [rsp+14h] [rbp-Ch]

  v1 = *a1;
  *a1 = a1[1];
  a1[1] = v1;
  ++*((_QWORD *)a1 + 2);
}
void __fastcall op_mul(__int64 a1)
{
  *(_DWORD *)a1 *= *(_DWORD *)(a1 + 12);
  ++*(_QWORD *)(a1 + 16);
}
void __fastcall op_nop(__int64 a1)
{
  ++*(_QWORD *)(a1 + 16);
}
void __fastcall op_input(__int64 a1)
{
  const char *buf; // [rsp+10h] [rbp-10h]

  buf = (const char *)res;
  read(0, res, 0x20uLL);
  dword_2022A4 = strlen(buf);
  if ( dword_2022A4 != 21 )
  {
    puts("WRONG!");
    exit(0);
  }
  ++*(_QWORD *)(a1 + 16);
}
void __fastcall op_xor(__int64 a1)
{
  *(_DWORD *)a1 ^= *(_DWORD *)(a1 + 4);
  ++*(_QWORD *)(a1 + 16);
}
void __fastcall op_mov(__int64 a1)
{
  int *v1; // [rsp+28h] [rbp-18h]

  v1 = (int *)(*(_QWORD *)(a1 + 16) + 2LL);
  switch ( *(_BYTE *)(*(_QWORD *)(a1 + 16) + 1LL) )
  {
    case 0xE1:
      *(_DWORD *)a1 = *((char *)res + *v1);
      break;
    case 0xE2:
      *(_DWORD *)(a1 + 4) = *((char *)res + *v1);
      break;
    case 0xE3:
      *(_DWORD *)(a1 + 8) = *((char *)res + *v1);
      break;
    case 0xE4:
      *((_BYTE *)res + *v1) = *(_DWORD *)a1;
      break;
    case 0xE5:
      *(_DWORD *)(a1 + 12) = *((char *)res + *v1);
      break;
    case 0xE7:
      *((_BYTE *)res + *v1) = *(_DWORD *)(a1 + 4);
      break;
    default:
      break;
  }
  *(_QWORD *)(a1 + 16) += 6LL;
}
void __fastcall dispatcher(__int64 a1)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 18;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_QWORD *)(a1 + 16) = &opcode;
  *(_BYTE *)(a1 + 24) = 0xF1;
  *(_QWORD *)(a1 + 32) = op_mov;
  *(_BYTE *)(a1 + 40) = 0xF2;
  *(_QWORD *)(a1 + 48) = op_xor;
  *(_BYTE *)(a1 + 56) = 0xF5;
  *(_QWORD *)(a1 + 64) = op_input;
  *(_BYTE *)(a1 + 72) = 0xF4;
  *(_QWORD *)(a1 + 80) = op_nop;
  *(_BYTE *)(a1 + 88) = 0xF7;
  *(_QWORD *)(a1 + 96) = op_mul;
  *(_BYTE *)(a1 + 104) = 0xF8;
  *(_QWORD *)(a1 + 112) = op_swp;
  *(_BYTE *)(a1 + 120) = 0xF6;
  *(_QWORD *)(a1 + 128) = op_cal;
  res = malloc(0x512uLL);
  memset(res, 0, 0x512uLL);
}
void __fastcall __noreturn main(int a1, char **a2, char **a3)
{
  __int64 v3[2]; // [rsp+10h] [rbp-10h] BYREF

  v3[1] = __readfsqword(0x28u);
  v3[0] = 0LL;
  puts("Please input something:");
  dispatcher((__int64)v3);
  vm_run((__int64)v3);
  check_flag();
  puts("And the flag is GWHT{true flag}");
  exit(0);
}
```

从网上嗦个脚本跑：

```python
opcode = [0xF5, 0xF1, 0xE1, 0x00, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,
          0x20, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x01, 0x00, 0x00, 0x00,
          0xF2, 0xF1, 0xE4, 0x21, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,
          0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x22, 0x00, 0x00, 0x00,
          0xF1, 0xE1, 0x03, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x23,
          0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00, 0x00, 0xF2,
          0xF1, 0xE4, 0x24, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00,
          0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x25, 0x00, 0x00, 0x00, 0xF1,
          0xE1, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x26, 0x00,
          0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00, 0x00, 0xF2, 0xF1,
          0xE4, 0x27, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08, 0x00, 0x00,
          0x00, 0xF2, 0xF1, 0xE4, 0x28, 0x00, 0x00, 0x00, 0xF1, 0xE1,
          0x09, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x29, 0x00, 0x00,
          0x00, 0xF1, 0xE1, 0x0A, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,
          0x2A, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0B, 0x00, 0x00, 0x00,
          0xF2, 0xF1, 0xE4, 0x2B, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0C,
          0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2C, 0x00, 0x00, 0x00,
          0xF1, 0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2D,
          0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00, 0xF2,
          0xF1, 0xE4, 0x2E, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0F, 0x00,
          0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x2F, 0x00, 0x00, 0x00, 0xF1,
          0xE1, 0x10, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x30, 0x00,
          0x00, 0x00, 0xF1, 0xE1, 0x11, 0x00, 0x00, 0x00, 0xF2, 0xF1,
          0xE4, 0x31, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x12, 0x00, 0x00,
          0x00, 0xF2, 0xF1, 0xE4, 0x32, 0x00, 0x00, 0x00, 0xF1, 0xE1,
          0x13, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x33, 0x00, 0x00,
          0x00, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF5, 0xF1,
          0xE1, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x01, 0x00, 0x00,
          0x00, 0xF2, 0xF1, 0xE4, 0x00, 0x00, 0x00, 0x00, 0xF1, 0xE1,
          0x01, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x02, 0x00, 0x00, 0x00,
          0xF2, 0xF1, 0xE4, 0x01, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x02,
          0x00, 0x00, 0x00, 0xF1, 0xE2, 0x03, 0x00, 0x00, 0x00, 0xF2,
          0xF1, 0xE4, 0x02, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x03, 0x00,
          0x00, 0x00, 0xF1, 0xE2, 0x04, 0x00, 0x00, 0x00, 0xF2, 0xF1,
          0xE4, 0x03, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x04, 0x00, 0x00,
          0x00, 0xF1, 0xE2, 0x05, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4,
          0x04, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x05, 0x00, 0x00, 0x00,
          0xF1, 0xE2, 0x06, 0x00, 0x00, 0x00, 0xF2, 0xF1, 0xE4, 0x05,
          0x00, 0x00, 0x00, 0xF1, 0xE1, 0x06, 0x00, 0x00, 0x00, 0xF1,
          0xE2, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x08, 0x00, 0x00,
          0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6, 0xF7, 0xF1,
          0xE4, 0x06, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x07, 0x00, 0x00,
          0x00, 0xF1, 0xE2, 0x08, 0x00, 0x00, 0x00, 0xF1, 0xE3, 0x09,
          0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00, 0x00, 0xF6,
          0xF7, 0xF1, 0xE4, 0x07, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x08,
          0x00, 0x00, 0x00, 0xF1, 0xE2, 0x09, 0x00, 0x00, 0x00, 0xF1,
          0xE3, 0x0A, 0x00, 0x00, 0x00, 0xF1, 0xE5, 0x0C, 0x00, 0x00,
          0x00, 0xF6, 0xF7, 0xF1, 0xE4, 0x08, 0x00, 0x00, 0x00, 0xF1,
          0xE1, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x13, 0x00, 0x00,
          0x00, 0xF8, 0xF1, 0xE4, 0x0D, 0x00, 0x00, 0x00, 0xF1, 0xE7,
          0x13, 0x00, 0x00, 0x00, 0xF1, 0xE1, 0x0E, 0x00, 0x00, 0x00,
          0xF1, 0xE2, 0x12, 0x00, 0x00, 0x00, 0xF8, 0xF1, 0xE4, 0x0E,
          0x00, 0x00, 0x00, 0xF1, 0xE7, 0x12, 0x00, 0x00, 0x00, 0xF1,
          0xE1, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE2, 0x11, 0x00, 0x00,
          0x00, 0xF8, 0xF1, 0xE4, 0x0F, 0x00, 0x00, 0x00, 0xF1, 0xE7,
          0x11, 0x00, 0x00, 0x00, 0xF4]
for i in range(len(opcode)):
    match opcode[i]:
        case 0xF1:
            print(f"{i}", end=" ")
            k = i + 1
            match opcode[k]:
                case 0xE1:
                    print("mov reg[0], flag[%d]" % opcode[i + 2])
                case 0xE2:
                    print("mov reg[1], flag[%d]" % opcode[i + 2])
                case 0xE3:
                    print("mov reg[2], flag[%d]" % opcode[i + 2])
                case 0xE4:
                    print("mov flag[%d], reg[0]" % opcode[i + 2])
                case 0xE5:
                    print("mov reg[3], flag[%d]" % opcode[i + 2])
                case 0xE7:
                    print("mov flag[%d], reg[1]" % opcode[i + 2])
            i += 6
        case 0xF2:
            print(f"{i} xor reg[0], reg[1]")
            i += 1
        case 0xF5:
            print(f"{i} cmp 21")
            i += 1
        case 0xF4:
            print(f"{i} nop")
            i += 1
        case 0xF7:
            print(f"{i} mul reg[0], reg[3]")
            i += 1
        case 0xF8:
            print(f"{i} swap reg[0], reg[1]")
            i += 1
        case 0xF6:
            print(f"{i} reg[0] = reg[2] + reg[1]*2 + reg[0]*3")
            i += 1
```

结果如下：

```
0 cmp 21
1 mov reg[0], flag[0]
7 xor reg[0], reg[1]
8 mov flag[32], reg[0]
14 mov reg[0], flag[1]
20 xor reg[0], reg[1]
21 mov flag[33], reg[0]
27 mov reg[0], flag[2]
33 xor reg[0], reg[1]
34 mov flag[34], reg[0]
40 mov reg[0], flag[3]
46 xor reg[0], reg[1]
47 mov flag[35], reg[0]
53 mov reg[0], flag[4]
59 xor reg[0], reg[1]
60 mov flag[36], reg[0]
66 mov reg[0], flag[5]
72 xor reg[0], reg[1]
73 mov flag[37], reg[0]
79 mov reg[0], flag[6]
85 xor reg[0], reg[1]
86 mov flag[38], reg[0]
92 mov reg[0], flag[7]
98 xor reg[0], reg[1]
99 mov flag[39], reg[0]
105 mov reg[0], flag[8]
111 xor reg[0], reg[1]
112 mov flag[40], reg[0]
118 mov reg[0], flag[9]
124 xor reg[0], reg[1]
125 mov flag[41], reg[0]
131 mov reg[0], flag[10]
137 xor reg[0], reg[1]
138 mov flag[42], reg[0]
144 mov reg[0], flag[11]
150 xor reg[0], reg[1]
151 mov flag[43], reg[0]
157 mov reg[0], flag[12]
163 xor reg[0], reg[1]
164 mov flag[44], reg[0]
170 mov reg[0], flag[13]
176 xor reg[0], reg[1]
177 mov flag[45], reg[0]
183 mov reg[0], flag[14]
189 xor reg[0], reg[1]
190 mov flag[46], reg[0]
196 mov reg[0], flag[15]
202 xor reg[0], reg[1]
203 mov flag[47], reg[0]
209 mov reg[0], flag[16]
215 xor reg[0], reg[1]
216 mov flag[48], reg[0]
222 mov reg[0], flag[17]
228 xor reg[0], reg[1]
229 mov flag[49], reg[0]
235 mov reg[0], flag[18]
241 xor reg[0], reg[1]
242 mov flag[50], reg[0]
248 mov reg[0], flag[19]
254 xor reg[0], reg[1]
255 mov flag[51], reg[0]
261 nop
288 cmp 21
289 mov reg[0], flag[0]
295 mov reg[1], flag[1]
301 xor reg[0], reg[1]
302 mov flag[0], reg[0]
308 mov reg[0], flag[1]
314 mov reg[1], flag[2]
320 xor reg[0], reg[1]
321 mov flag[1], reg[0]
327 mov reg[0], flag[2]
333 mov reg[1], flag[3]
339 xor reg[0], reg[1]
340 mov flag[2], reg[0]
346 mov reg[0], flag[3]
352 mov reg[1], flag[4]
358 xor reg[0], reg[1]
359 mov flag[3], reg[0]
365 mov reg[0], flag[4]
371 mov reg[1], flag[5]
377 xor reg[0], reg[1]
378 mov flag[4], reg[0]
384 mov reg[0], flag[5]
390 mov reg[1], flag[6]
396 xor reg[0], reg[1]
397 mov flag[5], reg[0]
403 mov reg[0], flag[6]
409 mov reg[1], flag[7]
415 mov reg[2], flag[8]
421 mov reg[3], flag[12]
427 reg[0] = reg[2] + reg[1]*2 + reg[0]*3
428 mul reg[0], reg[3]
429 mov flag[6], reg[0]
435 mov reg[0], flag[7]
441 mov reg[1], flag[8]
447 mov reg[2], flag[9]
453 mov reg[3], flag[12]
459 reg[0] = reg[2] + reg[1]*2 + reg[0]*3
460 mul reg[0], reg[3]
461 mov flag[7], reg[0]
467 mov reg[0], flag[8]
473 mov reg[1], flag[9]
479 mov reg[2], flag[10]
485 mov reg[3], flag[12]
491 reg[0] = reg[2] + reg[1]*2 + reg[0]*3
492 mul reg[0], reg[3]
493 mov flag[8], reg[0]
499 mov reg[0], flag[13]
505 mov reg[1], flag[19]
511 swap reg[0], reg[1]
512 mov flag[13], reg[0]
518 mov flag[19], reg[1]
524 mov reg[0], flag[14]
530 mov reg[1], flag[18]
536 swap reg[0], reg[1]
537 mov flag[14], reg[0]
543 mov flag[18], reg[1]
549 mov reg[0], flag[15]
555 mov reg[1], flag[17]
561 swap reg[0], reg[1]
562 mov flag[15], reg[0]
568 mov flag[17], reg[1]
574 nop
```

发现288处是输入，也就是说前面部分都是忽悠人的。

看一下后面的加密逻辑差不多是：

```
flag[0] = flag[0] ^ flag[1]
flag[1] = flag[1] ^ flag[2]
flag[2] = flag[2] ^ flag[3]
flag[3] = flag[3] ^ flag[4]
flag[4] = flag[4] ^ flag[5]
flag[5] = flag[5] ^ flag[6]
flag[6] = (flag[6]*3+flag[7]*2+flag[8])*flag[12]
flag[7] = (flag[7]*3+flag[8]*2+flag[9])*flag[12]
flag[8] = (flag[8]*3+flag[9]*2+flag[10])*flag[12]
swap flag[13] flag[19]
swap flag[14] flag[18]
swap flag[15] flag[17]
```

网上偷的exp：

```python
from z3 import *
f1 = [0x69, 0x45, 0x2A, 0x37, 0x09, 0x17, 0xC5, 0x0B, 0x5C, 0x72,
      0x33, 0x76, 0x33, 0x21, 0x74, 0x31, 0x5F, 0x33, 0x73, 0x72]
f1[15], f1[17] = f1[17], f1[15]
f1[13], f1[19] = f1[19], f1[13]
f1[14], f1[18] = f1[18], f1[14]
s = Solver()
f = [BitVec(f"f{[i]}", 8) for i in range(13)]
s.add(f1[0] == f[0] ^ f[1])
s.add(f1[1] == f[1] ^ f[2])
s.add(f1[2] == f[2] ^ f[3])
s.add(f1[3] == f[3] ^ f[4])
s.add(f1[4] == f[4] ^ f[5])
s.add(f1[5] == f[5] ^ f[6])
s.add(f1[6] == (3 * f[6] + 2 * f[7] + f[8]) * f[12])
s.add(f1[7] == (3 * f[7] + 2 * f[8] + f[9]) * f[12])
s.add(f1[8] == (3 * f[8] + 2 * f[9] + f[10]) * f[12])
s.add(f1[9] == f[9])
s.add(f1[10] == f[10])
s.add(f1[11] == f[11])
s.add(f1[12] == f[12])
if s.check() == sat:
    t = s.model()
    for i in f:
        print(chr(t[i].as_long()), end='')
    print(bytes(f1[-7:]).decode())
```

### [HGAME 2023 week4]shellcode

太抽象了这题，Base64解码出的二进制反汇编得TEA加密。

```c++
#include <cstdio>
using namespace std;
const unsigned int key[4]={22,33,44,55},delta=0x543210DD;
unsigned int enc[10]={0xE4B36920,0x936924D0,0xA816D144,0xAA82D5F5,0x3679F0DA,0x7F32FD06,0x3460C0D3,0xB7214939,0xE57269A2,0x836A51FA};
void TEA_decrypt(unsigned int enc1,unsigned int enc2){
    unsigned int v0=enc1,v1=enc2,sum=-32*delta;
    for(int i=0;i<32;i++){
        v1-=((((v0<<4)+key[2])^(v0+sum)^((v0>>5)+key[3])));
        v0-=((((v1<<4)+key[0])^(v1+sum)^((v1>>5)+key[1])));
        sum+=delta;
    };
    printf("%8x%8x",v0,v1);
    return;
};
int main(void){
    for(int i=0;i<10;i+=2)
        TEA_decrypt(enc[i],enc[i+1]);
    return 0;
};
```

### [长安杯 2021学生组]snake

第一个点在0x14F4处，改为`jnz`。改之前为碰到“\$”才算下一关，改之后走一步就算过。

第二个点在0x158B处，改为`jz`，`show_score`意味着结束。

然后他会一关一关跑，当正好碰到“\$”时会停下来。因为初始化后蛇是横着的，左右走不好说，一般选择上下走。

### [AFCTF 2018]JPython

就是字节码的单字节替换，找一下，有不少重复的：

```python
f1 = open('./hash.pyc','rb').read()
f2 = open('./Jhash.pyc','rb').read()
print('{')
for i in range(len(f1)):
    if f1[i] != f2[i]:
        t1 = f1[i]
        t2 = f2[i]
        print(hex(t1),':',hex(t2),',')
print('}')
```

没去重的：

```
{
0x64 : 0x94 ,
0x64 : 0x94 ,
0x6c : 0x75 ,
0x5a : 0x45 ,
0x64 : 0x94 ,
0x5a : 0x45 ,
0x64 : 0x94 ,
0x5a : 0x45 ,
0x64 : 0x94 ,
0x5a : 0x45 ,
0x65 : 0x95 ,
0x64 : 0x94 ,
0x64 : 0x94 ,
0x5a : 0x45 ,
0x65 : 0x95 ,
0x64 : 0x94 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x18 : 0x27 ,
0x14 : 0x23 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x17 : 0x26 ,
0x14 : 0x23 ,
0x17 : 0x26 ,
0x5a : 0x45 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x17 : 0x26 ,
0x14 : 0x23 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x18 : 0x27 ,
0x14 : 0x23 ,
0x17 : 0x26 ,
0x5a : 0x45 ,
0x65 : 0x95 ,
0x5a : 0x45 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x65 : 0x95 ,
0x64 : 0x94 ,
}
```

找个脚本替换：

```python
x={148:100,117:108,69:90,149:101,39:24,35:20,38:23}
f3=open('Jflag.pyc','rb').read().decode('ISO-8859-1')
t3=f3.translate(x).encode('ISO-8859-1')
open('flag.pyc','wb').write(t3)
```

用uncompyle6发现还是反编译不成功，但报错信息足够多了：

```
# file flag.pyc
# --- This code section failed: ---

 L.   1         0  JUMP_ABSOLUTE        12  'to 12'
                3  LOAD_CONST               None
                6  IMPORT_NAME           0  'time'
                9  STORE_NAME            0  'time'

 L.   2        12  LOAD_CONST               -1
               15  LOAD_CONST               None
               18  IMPORT_NAME           1  'base64'
               21  STORE_NAME            1  'base64'

 L.   3        24  LOAD_CONST               -1
               27  LOAD_CONST               None
               30  IMPORT_NAME           2  'sys'
               33  STORE_NAME            2  'sys'

 L.   6        36  LOAD_NAME             2  'sys'
               39  LOAD_ATTR             3  'argv'
               42  LOAD_CONST               1
               45  BINARY_SUBSCR
               46  STORE_NAME            4  'flag'

 L.   7        49  LOAD_CONST               'jd'
               52  STORE_NAME            5  'jd'

 L.   8        55  LOAD_NAME             6  'len'
               58  LOAD_NAME             4  'flag'
               61  CALL_FUNCTION_1       1  None
               64  LOAD_CONST               30
               67  COMPARE_OP            2  ==
               70  POP_JUMP_IF_FALSE   210  'to 210'

 L.   9        73  LOAD_NAME             1  'base64'
               76  LOAD_ATTR             7  'b64encode'
               79  LOAD_NAME             4  'flag'
               82  LOAD_CONST               '+1s+1s+1s'
               85  BINARY_ADD
               86  LOAD_NAME             5  'jd'
               89  LOAD_CONST               2
               92  BINARY_MULTIPLY
               93  BINARY_ADD
               94  CALL_FUNCTION_1       1  None
               97  STORE_NAME            8  'base64_str'

 L.  10       100  LOAD_CONST               ''
              103  STORE_NAME            9  'b'

 L.  11       106  SETUP_LOOP           73  'to 182'
              109  LOAD_NAME            10  'range'
              112  LOAD_CONST               0
              115  LOAD_CONST               44
              118  CALL_FUNCTION_2       2  None
              121  GET_ITER
              122  FOR_ITER             56  'to 181'
              125  STORE_NAME           11  'i'

 L.  12       128  LOAD_NAME            12  'ord'
              131  LOAD_NAME             8  'base64_str'
              134  LOAD_NAME            11  'i'
              137  BINARY_SUBSCR
              138  CALL_FUNCTION_1       1  None
              141  LOAD_CONST               10
              144  <36>
              145  STORE_NAME           13  'head'

 L.  13       148  LOAD_NAME             9  'b'
              151  LOAD_NAME            14  'chr'
              154  LOAD_NAME            12  'ord'
              157  LOAD_NAME             8  'base64_str'
              160  LOAD_NAME            11  'i'
              163  BINARY_SUBSCR
              164  CALL_FUNCTION_1       1  None
              167  LOAD_CONST               7
              170  BINARY_XOR
              171  CALL_FUNCTION_1       1  None
              174  INPLACE_ADD
              175  STORE_NAME            9  'b'
              178  JUMP_BACK           122  'to 122'
              181  POP_BLOCK
            182_0  COME_FROM           106  '106'

 L.  14       182  LOAD_NAME             9  'b'
              185  LOAD_CONST               '^P]mc@]0emZ7VOZ2_}A}VBwpbQ?5e5>lN4UwSSM>L}A}'
              188  COMPARE_OP            2  ==
              191  POP_JUMP_IF_FALSE   202  'to 202'

 L.  15       194  LOAD_CONST               'Congratllations!Yol Get Flag'
              197  PRINT_ITEM
              198  PRINT_NEWLINE_CONT
              199  JUMP_ABSOLUTE       210  'to 210'

 L.  17       202  LOAD_CONST               'Wrong!'
              205  PRINT_ITEM
              206  PRINT_NEWLINE_CONT
              207  JUMP_FORWARD          0  'to 210'
            210_0  COME_FROM           207  '207'

Parse error at or near `None' instruction at offset -1
```

写个脚本解密：

```python
from base64 import b64decode
s = b"^P]mc@]0emZ7VOZ2_}A}VBwpbQ?5e5>lN4UwSSM>L}A}"
s  = [(_ ^ 7) for _ in s]
s = ''.join([chr(x) for x in s])
print(s)
```

发现`s`中出现了俩非法字符“]”，那就挨个试，试到“B”，Base64解密即可。

### [suctf 2019]signin

密码题跑re里了...，经典RSA，$n$直接丢factordb里就能分解出来。

```python
from Crypto.Util.number import *
p=282164587459512124844245113950593348271
q=366669102002966856876605669837014229419
e=65537
c=0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35
phi=(p-1)*(q-1)
n=p*q
d=inverse(e,phi)
m=pow(c,d,n)
print(long_to_bytes(m))
```

## 0410

### （不会）[De1ctf 2019]Cplusplus

会不了一点，看网上wp应该是动调猜。

### [suctf 2019]hardcpp

经典控制流平台化，用D\-810解决。输出了个MD5提示，去网上解出来是“#”的MD5。

一堆Lambda表达式，直接硬杠然后写exp：

```python
enc=[0xF3,0x2E,0x18,0x36,0xE1,0x4C,0x22,0xD1,0xF9,0x8C,0x40,0x76,0xF4,0x0E,0x00,0x05,0xA3,0x90,0x0E,0xA5]
flag='#'
for i in range(1,21):
    tmp=((enc[i-1]^((ord(flag[i-1])^18)*3+2))-(ord(flag[i-1])%7))&0xFF
    flag+=chr(tmp)
    print(chr(tmp),end='')
```

其中提示给的“\#”就是输入的第一个字符，知道后就可以倒退。

### （不会）[suctf 2019]Rev

代码量过大，看不了。

### （不会）[湖湘杯 2021]hideit

应该是用`LoadLibrary`加载了个加密的DLL，但总是调飞，调不了一点。

先写个ChaCha20的解密脚本：

```python
from Crypto.Cipher import ChaCha20
secret=
nonce=
ciphertext=
cipher=ChaCha20.new(key=secret,nonce=nonce)
plaintext=cipher.decrypt(ciphertext)
print(plaintext)
```

### [NCTF 2019]Our 16bit wars

16位程序阅读题，直接硬杠，写脚本爆破：

```python
enc=[0xC9,0x68,0x8A,0xC8,0x6F,0x07,0x06,0x0F,0x07,0xC6,0xEB,0x86,0x6E,0x6E,0x66,0xAD,0x4C,0x8D,0xAC,0xEB,0x26,0x6E,0xEB,0xCC,0xAE,0xCD,0x8C,0x86,0xAD,0x66,0xCD,0x8E,0x86,0x8D,0xAF]
for i in range(len(enc)):
    for j in range(0,0xff+1):
        if (j>>3)^(j<<5)&0xff==enc[i]:
            print(chr(j),end='')
            break
```

### （不会）[蓝帽杯 2022 初赛]loader

想直接做题的话直接动调找主逻辑就好了，但是加载部分比较有趣。

先是`VirtualProtect`改.data段的权限为“RWX”，然后再下一个函数中溢出覆盖掉RIP，劫持控制流到新地址。

```assembly
lods qword ptr gs:[rsi] ;gs[0x60]指向当前进程的PEB x64下好像是0x30？
mov rax,[rax+18h] ;PEB:[0x18]为LDR指针 即PEB_LDR_DATA x64下为0x0C
mov rsi,[rax+20h] ;LDR:[0x20]为InMemoryOrderModuleList的指针 x64下为0x1C
```

“InMemoryOrderModuleList”是个双向链表结构，为“LDR_DATA_TABLE_ENTRY”类型，连接了若干结构体，每个结构体记录了加载进当前进程空间的一个模块。一般前两个分别为“NTDLL.DLL”和“KERNEL32.DLL”。

详细模块装载过程略，来到API装载阶段。

访问PE文件头，先访问“IMAGE_DOS_HEADER”的“e_lfanew”字段，表示“IMAGE_NT_HEADERS”与文件头的偏移。

访问“IMAGE_NT_HEADERS”的子结构体“IMAGE_OPTIONAL_HEADER”的“IMAGE_DATA_DIRECTORY”，该表的第一个为EAT，第二个为IAT，这里访问第一个，偏移0x20即为“AddressOfName”字段。

“0xEDB88320”是CRC校验中使用的数字。Shellcode常用CRC校验算法压缩API标识，再比较并勾取。

接下来就是主逻辑，但Nim写的，非常抽象。大概思路需要用Pell方程来解，但代码实在看不懂、猜不到也动调不出来。Pell方程直接拿WolframAlpha查。

### （不会）[NCTF 2021]狗狗的秘密

XTEA版的SMC，但动调出来的代码跟wp上的不对...

### [MoeCTF 2021]PEPEPE

脑洞题，给了个加密程序main.exe，又给了个加密文件file。file其实是个.exe经过加密后的，现在要把file_org文件搞出来。

切入点就在DOS_STUB是固定的，写个脚本解出输入的解密密钥，其中取反的逆运算是`^0xFF`：

```python
org1=b'This program cannot be run in DOS mode'
enc1=[0xDE,0xB6,0xE4,0xE9,0xA9,0xEA,0xFF,0xF9,0xFD,0xFF,0xE9,0xFB,0xB3,0xF0,0xF2,0xF8,0xFA,0xF5,0xF2,0xB0,0xE8,0xBB,0xAD,0xE8,0xFC,0xF4,0xAD,0xFF,0xF4,0xAD,0xCC,0xD9,0xC0,0xB3,0xFE,0xF9,0xF0,0xFF]
for i in range(len(enc1)):
    print(chr(enc1[i]^0xFF^org1[i]),end='')
```

发现是循环的“reverierwilllikeyou!”，解出来file_org：

```python
key=b'reverierwilllikeyou!'
f1=open('./file',"rb")
f2=open("./file_org","wb")
orgdata=f1.read()
tmpdata=[0]*len(orgdata)
for i in range(len(orgdata)):
    tmpdata[i]=orgdata[i]^0xFF^key[i%len(key)]
f2.write(bytes(tmpdata))
```

运行就是了。
