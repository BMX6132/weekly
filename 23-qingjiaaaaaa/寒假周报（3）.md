n1 junior的rsa感觉还是有些思路，但不多，先写一点再慢慢研究吧

from Crypto.Util.number import *
from secret import flag

m = bytes_to_long(flag)

def gen(bits):
    while True:
        a = getPrime(bits)
        b = getPrime(bits)
        c = getPrime(bits)
        p = (a << (2*bits)) + (b << bits) + c 
        q = (c << (2*bits)) + (a << bits) + b
        if isPrime(p) and isPrime(q):
            break
    n = p * q
    e = 65537 * a * b * c
    return n, e

n, e = gen(256)
enc = pow(m, e, n)
print(f'n = {n}')
print(f'e = {e}')
print(f'enc = {enc}')

<<是二进制向前先前移动，相当于乘以2的bits次方

所以现在可以得出 a\*b\*c=722594887948910568714666446958666053704548018730628441159257945707357519612887000462446117812580967222634925341809728087898931893069941625003834829769356531179683449892968133833334038870692798903228204063725365368404173596884408813

(a\*2\*\*512+b\*2\*\*256+c)\*(c\*2\*\*512+a\*2\**256+b)=1224562468550864572988516321107388462006452125881847529675226398144888628055678744854491489016309262856785169494723943649344959507818155642772331582922466943539371681776924160647697558836379614689120727659593775446187326222964118917872973684996317614900715927751822277949264379149585370840318817143291878609357893969588131470982041272505875501444442064552286330626234504767040724907034678080283717062342383737341651784574675215207283219694413200065153603535550259

但是后面就没有思路了……

rsa主要可以被分为：素数分解、p-q过小、dp泄露、p-1光滑、共享素数、p+1光滑、低加密指数攻击、共模攻击等（其他的目前我还没看）ai告诉我这样加密可能会导致p、q的数字比较相近，但是这个也开不出来平方，所以就没思路了

总结一下这些攻击的基本条件吧

**素数分解**

n比较小，直接暴力分解即可

**p-q过小**

p、q差距很小，可以开方

**dp泄露**

题目会给出n,c,e,dp，首先这个dp并不是单纯的d*p：dp≡dmod(p−1)

**共享素数**

当我们生成p和q的时候，难免有重复的，比如我们使用了p、q1和p、q2生成了n1和n2，就可以说我们的q被n1和n2共享了，如果我们能拿到这两个n，那么我们很容易就可以得到q1和q2

**共模攻击**

同一份明文m使用不同的秘钥加密了两次，两次生成秘钥时模数n相同但加密指数e不相同，我们能拿到两个不同的密文c1、c2和模数n、加密指数n1、n2

**低加密指数攻击**

所谓低加密指数指的就是e非常小的情况下

****

**图片隐写**

查看十六进制，用HexWorkshop将图片打开，搜索flag等关键字或翻到最后，可能会出现flag

右键属性，查看详细信息，可能会隐藏flag。

将文件后缀名改为zip或rar，图片可能会变成压缩包。正常的jpg图片是以FF D9结尾的，结尾 之后的东西不会被作为图片显示。图片查看器会忽视后面的东西，不会影响正常显示。 使用copy /b a.jpg+b.zip 3.jpg 会生成图种，更改后缀名即可解压或查看源文件， 当然这只是针对添加的文件是压缩文件的 情况，添加的文件也可以是其他图片，比 如两张图片叠加。这时需要用binwalk 可 以获得更详细的信息。

LSB隐写就是修改了像数中的最低的 1bit，人眼看来是看不出来区别的

之后我将一些以前写的内容（仓库里面没有）的附加在后面

前缀b

在Python中，前缀为b的字符串表示字节字符串（bytes string）。字节字符串是以字节为单位表示的数据序列，而不是以字符为单位的字符串。

在Python 3中，字符串默认使用Unicode编码，即使用字符集来表示文本。然而，在某些情况下，我们需要处理原始的字节数据，例如处理二进制文件、网络传输的数据或与底层系统交互的数据。这时就可以使用字节字符串来表示这些数据。

通过在字符串前面添加b前缀，Python将其标识为字节字符串而不是Unicode字符串。这告诉Python解释器将字符串内容视为原始字节数据，而不是字符序列。例如，b'Hello, world!'表示一个由ASCII字符组成的字节序列。

字节字符串与普通字符串之间有一些重要的区别。普通字符串是不可变的，而字节字符串是可变的。此外，字节字符串中的元素是整数值（0-255），而不是Unicode字符。这使得字节字符串在处理二进制数据时更加灵活和高效。

因此，当你需要处理原始的字节数据时，可以使用字节字符串来表示它们，并在字符串前面添加b前缀来标识它是一个字节字符串。

原始字节数据和字符序列的区别：

表示方式：原始字节数据是以字节为单位表示的，每个字节可以表示0-255之间的整数值。它们通常用于表示二进制数据，如图像、音频、视频等。而字符序列是由字符组成的，可以使用不同的编码方案将字符映射为字节序列。

编码：原始字节数据不依赖于任何特定的字符编码，它们只是简单地表示字节的值。而字符序列需要使用字符编码方案将字符转换为字节序列，以便在存储和传输时能够正确地表示和解码字符。

可变性：原始字节数据是可变的，可以通过修改字节的值来改变数据。而字符序列是不可变的，一旦创建就不能直接修改其中的字符，只能通过创建新的序列来实现修改。

字符集支持：字符序列可以表示各种字符集中的字符，如ASCII、Unicode等。每个字符可以由一个或多个字节表示，具体取决于所使用的编码方案。而原始字节数据没有字符集的概念，它们只是简单地表示字节值，可以包含任意的二进制数据。