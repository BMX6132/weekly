#辽宁考生的第二次周报

***

##前言

紧张而又刺激的第二周学习生活又要结束了，本来打算周日再写周报的，这样可能会显得学习内容多一点，但思来想去反正周五周六周日这三天也不是从我的世界里消失了，不如把他们仨放到下周里聊，咸盐少续

##本周完成任务

**1.**继续学习C语言

**2.**qsnctf新疆杯，nssctf

**3.**复盘二面题目

###C语言

总所周知，C语言可以算得上是底层的语言，在笔者呕心沥血不分昼夜的钻研之下，也是实现了三天一百页的壮举（但貌似还是好慢），大约是从数组到指针的初级应用，一下为笔者补充的笔记以及对于知识的理解

(1).指针的初级应用

>一个地址存八位(一个字节)，一个变量占多个字节也会横跨多个地址，而第一个地址就是它的真实地址，而指针就是地址，指针变量就是储存地址的变量
>
>常用符号\*：解指针
>
>常用符号\&：取指针
>
>我们在定义指针的时候通常喜欢用数据类型+\*+指针变量的方式来定义指针，但初学者(也有可能只有我一个人)会认为\*的作用是来声明一个int类型的指针，这句话就经得起推敲了，结合同种类型的指针只能指向同种类型变量地址这一特点，笔者理解这句话的意思是定义一个指针变量，这个指针变量解指针之后是某个数据类型的变量，所以\*在定义指针时其实起到的也是解指针的作用，这也就解释得通为什么一个指针变量只能指向跟他同种类型的变量了
>
>由此也衍生出了一个让人晦涩难懂的静态变量定义方法：
>
>const int \* p和int \* const p
>
>由以上结论可知，p就是一个指针变量，所以前者指p解指针后的int类型数据的值不变，后者则指p这个指针指向的地址不变
>
>数组c[]既是一个地址，也是一个常量，不能赋值，想输出c的数组要解指针（\*c），而为了实现数组中指针的前后移动，通常需要(\*(c+num))且对指针进行任何运算，都是起到移位的作用
>
>这也就衍生出了指针的加减，对于指针运算来说，只可加减整形或者二者相减，分别表示指针向高位，低位移动以及两个地址间的距离，但这里笔者还是有很多地方不明白，书上只是用数组来向读者展示指针的位移，但并没有指出是向高地址还是低地址移动，差值是一个多少进制的数，相信等学完C语言再去学习与汇编相关的书籍时，笔者可以找到答案
>
>数组名也可以做指针，但是数组名不能改变，也就是说a+1可以，因为a没改变，但是a++不行，因为a改变了
>
>一维数组c99中可以指定初始化如
>a[11]={a[3]=7}，如果下标省略，推测最大值为初始化下标最大值加一
>
>数组中可以用static，但二维数组就行(i)可以用，表示至少有多少数据
>
>变长数组(内存动态数组)
>
>变量种类
>内部变量(函数内部):
>局部变量为函数内部的变量，只在函数内部有效，再次调用会被初始化
>静态局部变量为函数内部的变量，为永久的储存单元，全局有效，用(static 数据类型 变量)定义
>外部变量(main中函数外):
>静态存储期限长，文件作用域为全局(从被声明开始)

以上为本周所学，下面根据课后题研究的编程训练

```c
#include <stdio.h>
#define N 10
int kkk(int a[],int low,int hig);
int lll(int a[],int low,int hig);

int kkk(int a[],int low,int hig){
	int mid;
	if(low>=hig)return 0;
	mid=lll(a,low,hig);
	kkk(a,low,mid-1);
	kkk(a,mid+1,hig);
}
int lll(int a[],int low,int hig){
	int b=a[low];
	
	for(;;){
		while(low<hig&&b<=a[hig])
		hig--;
		if(low>=hig) break;
		a[low++]=a[hig];
		while(low<hig&&a[low]<=b)
		low++;
		if(low>=hig)break;
		a[hig--]=a[low];
	}
	a[hig]=b;
	return hig;
}
int main(){
	int a[N],i;
	printf("往里搞%d个数字，快快滴\n",N);
	for(i=0;i<N;i++){
		scanf("%d",&a[i]);
	}
	kkk(a,0,N-1);
	printf("oi,小鬼,oi oi oi\n");
	for(i=0;i<N;i++){
		printf("%d ",a[i]);
	}
	 return 0;
}
```

这点玩意整了我大概两个多小时，说白了还是不熟练，欠练啊

###各种比赛

做了几道ret2text，还有个ret2libc(这道libc纯是水出来的)但真的找不到wp了，笔者已哭晕在厕所

但正经来说确实发现了很多基础性的问题，比如返回地址应该找谁这样

###复盘二面题目

因为已经要学习pwn方向了，所以就复盘了一下pwn的二面题目

**整数溢出**

打开IDA，发现数组，带了取地址符，正数下移负数上移，在距离他0x50的位置正好有一个binsh

##心得体会

>正如y爹所说，学pwn得有三个月的基础，去学底层，现在越学越有一种感觉，pwn这个东西是搭建在计算机底层的东西，真的要真正了解计算机的运作和很多很多底层(已经用了不知道多少个”底层了“，但真的很底层)的知识，有了这些基础才能真正学明白pwn，从c语言到汇编到深入理解计算机系统，由浅入深，可能这才是二进制安全的真面目，也是为什么pwn又难又晦涩上手还慢的原因，它不像杂项依赖于软件和广泛的见识，不像密码依赖于算法，不像web用途广泛且实惠，不像逆向那么有意思(至少在我眼里逆向工程是一个很实用很有趣的工程)
>
>但pwn很帅，每个pwn手都很帅。

##下周任务

1.结束c语言的学习

2.开始学习汇编语言

3.继续刷题，但要压缩时间，把时间多用到学习中去