*完成事项

1.学习ret2syscall，ret2libc

2.巩固c语言基础

4.学了一点点关于栈的知识

*下周的学习任务

1.继续学习c语言

2.学习汇编语言

3.完成pig提供的方向建议

4.大量做题

**菜鸟忆栈

栈从高地址向低地址增长，所以栈顶的地址最低，栈底的地址最高（个人理解有点像个倒着的杯子），先进入容器中的东西最后出来所以遵循先出后进，push为压入（栈中），pop为（从栈中）弹出，push的操作流程为sp（指向栈顶的指针）向下移动一个位置，再在那个位置写入数据，pop反之，而栈帧也属于一种栈，用于储存信息，如ebp，esp，一个栈空间可以有多个栈帧，每调用一个函数，就会生成一个新栈帧，返回值往往存在eax寄存器中且被调用的函数需要知道传入的参数在哪以及调用之后它的返回值在哪里（这句话理解的模模糊糊的，但我感觉是因为没太学明白汇编，所以暂时不问，估计再学一学就自然有答案了）控制函数返回的是ret指令，具体用法有点想c语言中的goto

**ret2syscall

因为还没学习汇编语言，也没研究透pwn的底层逻辑，所以对于ret2syscall只能说是新手入门，当文件反汇编之后没有找到/bin/sh，且开启段不可执行保护后（ret2text和ret2shellcode都没法整），发现存在syscall，且程序非动态链接，即可尝试使用ret2syscall系统调用

具体思路：gadgets找到并修改eax，ebx，ecx，edx寄存器的参数，让eax=0xb（execve），ebx指向/bin/sh，ecx和edx都为0，最后系统调用（int 0x80）

解题关键指令：ROPgadget --binary rop --only 'pop|ret' | grep 'eax'(b c d.)

​                                                                      --string '/bin/sh'

用来查找e（abcd）x和/bin/sh的位置，之后构建payload=填充字符，偏移量+p??(eax)+p??(0xb)(往里存地址从而调用)+\p??(b,c,d)+p??(0)+p??(0)+p??(/bin/sh)(先存的在高地址，最后赋值)+\p??(int 0x80)

然后基本上就没啥太大的问题了，要是有，那就留给学完汇编的辽宁考生解决吧

**ret2libc

ret2syscall解决了无/bin/sh且不可执行的问题，但如果文件中没有syscall可调用且文件为动态链接，那就只能试一试ret2libc了

而学习ret2libc之前要先明确plt表和got表简单来说plt表是一个位于代码段每条都是十六字节内容的数组，用于代码执行时访问函数，got表简单来说是一个位于数据段且每个条目是8字节存放函数地址的数组，函数将要被调用时要先到plt表中找这个函数的相关信息然后跳转的got表里查找函数地址最后才能被调用，而一些函数被存在libc库中（puts，printf，gets，read等）当然，我们的system函数和str_bin_sh也被存储在这个老是瞎跑的libc库里，想要从libc中调用出system和str_bin_sh非常之困难，但是libc的瞎跑是有规律的，所以

解题思路：1.elf解析文件然后构建第一个payload反向找一个存在于libc中函数的真实地址

payload=填充字符偏移量+p??(pop_rdi)+p??(elf.got['被调用过且存在于libc库中的函数'])+p??(elf.plt['同上'])+p64(elf.sym['main'])

发进去之后

那个函数的真实地址=u64(?.recvuntil(b'\x7f')[-6:].ljust(8,b'\x00'))(大概意思是解码读取到x7f之后取六个字节，这个是准的，然后给他补充成八个字节，因为在六十四位系统里地址得有八个字节，要是三十二位就不用补充了，直接读取四个字节)

因为真实地址=基地址+偏移，所以我们利用以上公式以及LibcSearther里计算便宜的函数libc.dump('??')就可以计算出system和str_bin_sh的真实地址，最后再构建一个payload2=填充字符偏移量+ret(在init段，返回)+pop_rdi+system+/bin/sh就差不多了

**C语言巩固学习

虽然过了一面，也有了一点入门级别的编程能力，但在一个月之前刚开始接触c语言一直到进入实验室，c语言的学习一直都是不成体系的，所有的知识点在我脑子中都是一个凌乱的状态，所以笔者打算在进入实验室之后大约三周的时间用pig和y爹推荐的c语言书籍从头到尾再次学习一遍，即使巩固也是加强，既是复习也是学习，暂时只看到了数组，就在这里写一些笔记上的补充内容吧

-无限循环for( ; ; )

-goto类似于调用函数

-类型转换有等级
   long long>long int>short int>char>_Bool

-\0空格(休止)，会让句子停止
  \n回车(不休止)，不让句子停止

-17.宏常量
#define x 13131331
不加分号，没有数据类型（后面是啥就代表啥，比如#define k a+b k代表的就是a+b而不是其和）
const 数据类型 x=k
定义时就赋值(会变)

-23.指令补充
#typedef float k
以后k就代表着float

其实记了好多笔记，但很多都是已经学会的了，这里就只写一部分以前没接触过的

*遇到的问题

1.利用已经学过的知识点解体，有的解的出来，有的解不出来

2.每次对着IDA发懵，不用F5大法好像就不认识这个软件了

3.C语言还是有问题，至少还没法编出一个像样的程序，只能解决一些小孩过家家的问题

4.还是不会用gdb(我是真废物啊啊啊，受够啦)

*解决方案

前两天做极客的pwn做红温了，一道ret2text和一道ret2shellcode都没做上来，开始怀疑自己了，但后来很幸运，枫✌跟我说这是很正常的情况，就是多学多看多做题，其实反思一下，这一周都是在看书看文献，学了很多但真的有一点脱离实践，用y爹的话说就是闭门造车，所以下一周在学习的同时也要抽出时间（每天八点以后吧）去靶场做题，认真看wp，可能这样才能真正提升自己，至于gdb的问题就求求我最爱的pig啦，但要是pig没时间那也只好自学了，唉，加油加油

*结语

这是来实验室的第一周，有点回到高三的感觉，过的非常充实和快乐，可能对于辽宁考生来说沉浸在这种氛围里才会让他感受到若即若离的归属感，接下来的大体学习方向应该还是顺应pig给我留的学习任务，但可能我要把时间和精力更大的花费在y爹所说学习底层逻辑这方面，正如敬爱的y爹所说，研究二进制漏洞一定要学习最底层的东西，同时，也要每天花时间去靶场练习，这不仅是枫✌给我传授的经验，可能也是pig真正希望我去完成的任务，文章的最后，赞美pig，赞美y爹，赞美枫✌，赞美智邮普创实验室

（啊对了，下次写周报我还是直接以学长相称吧，不然pig，y爹和枫✌...总感觉哪里怪怪的）