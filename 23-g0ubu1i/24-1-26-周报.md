# 本周：
学习nuclei用法
编写nuclei模板
学习DES
做题

# 下周：
HGAME2024
BeginCTF
N1CTF junior

# 学到的东西
## CTF
### [黑盾杯 2020]Factor
思路：
n比较小，可以直接分解，但发现无法得到d
首先分解n，然后取和e互质的因数，得到新的phi，n。然后求m
exp：
```python
from Crypto.Util.number import *

n = 3454083680130687060405946528826790951695785465926614724373
e = 3
c = 1347530713288996422676156069761604101177635382955634367208

p=11761833764528579549
q=17100682436035561357
r3=17172929050033177661

P = [p,q,r3]
n=1
phi = 1
for i in P:
    if GCD(e,(i-1)) == 1:
        phi *= (i-1)
        n *= i
d = inverse(e,phi)
m = long_to_bytes(pow(c,d,n))
print(m)
```
总结：
GCD(e,phi)=e,用常规的e与phi不互素的做法做不出来，但p-1 与e互素，用它求得新的phi与n，求解m
### [NSSCTF 2022 Spring Recruit]factor
思路：
简单的分解，然后用hashlib的md5加密
exp：
```python
import hashlib
#flag:NSSCTF{md5(min(p,q)+max(p,q))}

p=13891650093628440437
q=17315890900809982861

md5 = hashlib.md5()
md5.update(str(min(p,q)+max(p,q)).encode('utf-8'))
print(md5.hexdigest())
```
### [LitCTF 2023]P_Leak
思路：
dp泄露
exp：
```python
from Crypto.Util.number import *
import gmpy2
e=65537
""" m=bytes_to_long(b'xxxx')
p=getPrime(512)
q=getPrime(512)
n=p*q
phi=(p-1)*(q-1)
d=inverse(e,phi)
dp=d%(p-1)
c=pow(m,e,n)
print("dp=",dp)
print("n=",n)
print("c=",c) """


dp= 5892502924236878675675338970704766304539618343869489297045857272605067962848952532606770917225218534430490745895652561015493032055636004130931491316020329
n= 50612159190225619689404794427464916374543237300894011803225784470008992781409447214236779975896311093686413491163221778479739252804271270231391599602217675895446538524670610623369953168412236472302812808639218392319634397138871387898452935081756580084070333246950840091192420542761507705395568904875746222477
c= 39257649468514605476432946851710016346016992413796229928386230062780829495844059368939749930876895443279723032641876662714088329296631207594999580050131450251288839714711436117326769029649419789323982613380617840218087161435260837263996287628129307328857086987521821533565738409794866606381789730458247531619

for i in range(1,e):                   
    if(dp*e-1)%i == 0:
        if n%(((dp*e-1)//i)+1) == 0:   
            p=((dp*e-1)//i)+1
            q=n//(((dp*e-1)//i)+1)
            phi=(q-1)*(p-1)            
            d=gmpy2.invert(e,phi)         
            m=pow(c,d,n)               
print(m)                              

print(bytes.fromhex(hex(m)[2:]))
```
总结：
dp泄露
### [LitCTF 2023]Virginia
过程： 根据题目提示为维吉尼亚密码，文本长，尝试爆破key，发现进行了两次加密，给出了ascll码的列表，并提示是凯撒加密，查表看变化规律，发现为变异凯撒，根据变化规律写出exp
### [黑盾杯 2020]Round
思路：
根据题目提示为周期类的，试着爆破变化规律或者根据flag开头猜位移
exp：
```python
c = ":D@J::K=r<ecXi^\[V:X\jXit"
flag = ""
for i in range(1,10):
    flag = ""
    for j in c:
        flag += chr(ord(j) + i)
    print(flag)
```
得到位移为9
### [LitCTF 2023]easy_math (中级)
思路 
简单的解方程，用sympy库解出pq，然后求解
exp：
```python

from Crypto.Util.number import *
from sympy import*
""" from secret import flag

m = bytes_to_long(flag)
e = 65537
p = getPrime(512)
q = getPrime(128)
n = p*q
hint = p**3-q**5
c = pow(m,e,n)
print(f'n = {n}')
print(f'c = {c}')
print(f'hint = {hint}') """
n = 2230791374046346835775433548641067593691369485828070649075162141394476183565187654365131822111419512477883295758461313983481545182887415447403634720326639070667688614534290859200753589300443797
c = 2168563038335029902089976057856861885635845445863841607485310134441400500612435296818745930370268060353437465666224400129105788787423156958336380480503762222278722770240792709450637433509537280
hint = 392490868359411675557103683163021977774935163924606169241731307258226973701652855448542714274348304997416149742779376023311152228735117186027560227613656229190807480010615064372521942836446425717660375242197759811804760170129768647414717571386950790115746414735411766002368288743086845078803312201707960465419405926186622999423245762570917629351110970429987377475979058821154568001902541710817731089463915930932142007312230897818177067675996751110894377356758932
e = 65537
x = Symbol('x')
y = Symbol('y')
p,q = solve([x*y-n,x**3-y**5-hint],[x,y])[0]
p=7321664971326604351487965655099805117568571010588695608389113791312918573783115429227542573780838065461696504325762281209452761930184231131129306271846427
q=304683618109085947723284393392507415311
phi = (p-1)*(q-1)
d = inverse(e,phi)
print(long_to_bytes(pow(c,d,n)))
```
### [NISACTF 2022]funnycaeser
思路：根据提示为凯撒密码，flag开头应该为NSSCTF{}
尝试每进以为位移加1，得到类似的flag，根据ascll码表，当密文为符号是，位移需要加5，得到flag（需要改动）
exp：
```python
import string
c = r"NRQ;P<uLliW^(XQ/QT\NDh"
flag = ""
a = 0
for i in c:
    if i not in string.ascii_lowercase and i not in string.ascii_uppercase:
        m = chr(ord(i) + 5 +a )
    else: 
        m = chr(ord(i) + a)
    flag += m
    a += 1
print(flag)
```
