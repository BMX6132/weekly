# 本周
NSSCTF刷题
学数论
dvwa靶场刷
# 下周
NSSCTF刷题
学数论
dvwa靶场刷题

# 学到的东西
## 周天
### [HGAME 2023 week1]RSA
思路：
factor
exp:
……
### [HNCTF 2022 WEEK2]RSA again
思路：
两组数据，一组数据中e=3，低加密指数
exp：
```bash
from Crypto.Util.number import *
import gmpy2
e =3
c1 = ……
m = gmpy2.iroot(c1,3)[0]
print(long_to_bytes(m))
```
### [LitCTF 2023]Where is P?
思路：
得到a时，e=3，可以直接开立方得到p的高位
再由CopperSmith得到p，再得到q，求解
exp：
```bash
import gmpy2
n= 24479907029118467064460793139240403258697681144532146836881997837526487637306591893357774423547391867013441147680031968367449693796015901951120514250935018725570026327610524687128709707340727799633444550317834481416507364804274266363478822257132586592232042108076935945436358397787891169163821061005102693505011197453089873909085170776511350713452580692963748763166981047023704528272230392479728897831538235554137129584665886878574314566549330671483636900134584707867654841021494106881794644469229030140144595938886437242375435914268001721437309283611088568191856208951867342004280893021653793820874747638264412653721
c= 6566517934961780069851397787369134601399136324586682773286046135297104713708615112015588908759927424841719937322574766875308296258325687730658550956691921018605724308665345526807393669538103819281108643141723589363068859617542807984954436567078438099854340705208503317269397632214274507740533638883597409138972287275965697689862321166613821995226000320597560745749780942467497435742492468670016480112957715214640939272457886646483560443432985954141177463448896521810457886108311082101521263110578485768091003174683555938678346359150123350656418123918738868598042533211541966786594006129134087145798672161268647536724
a= 22184346235325197613876257964606959796734210361241668065837491428527234174610482874427139453643569493268653377061231169173874401139203757698022691973395609028489121048788465356158531144787135876251872262389742175830840373281181905217510352227396545981674450409488394636498629147806808635157820030290630290808150235068140864601098322473572121965126109735529553247807211711005936042322910065304489093415276688746634951081501428768318098925390576594162098506572668709475140964400043947851427774550253257759990959997691631511262768785787474750441024242552456956598974533625095249106992723798354594261566983135394923063605
e = 65537
"""for i in range(e):
    a1 = a+i*n
    if gmpy2.iroot(a1,3)[1]:
        print("p = ",gmpy2.iroot(a1,3)[0])"""
# 66302204855869216148926460265779698576660998574555407124043768605865908069722142097621926304390549253688814246272903647124801382742681337653915017783954290069842646020090511605930590064443141710086879668946

"""
from Crypto.Util.number import *
P = 66302204855869216148926460265779698576660998574555407124043768605865908069722142097621926304390549253688814246272903647124801382742681337653915017783954290069842646020090511605930590064443141710086879668946
n = 24479907029118467064460793139240403258697681144532146836881997837526487637306591893357774423547391867013441147680031968367449693796015901951120514250935018725570026327610524687128709707340727799633444550317834481416507364804274266363478822257132586592232042108076935945436358397787891169163821061005102693505011197453089873909085170776511350713452580692963748763166981047023704528272230392479728897831538235554137129584665886878574314566549330671483636900134584707867654841021494106881794644469229030140144595938886437242375435914268001721437309283611088568191856208951867342004280893021653793820874747638264412653721
kbits = 340
p_fake = P << kbits
pbits = p_fake.nbits()
pbar = p_fake & (2^pbits-2^kbits)
print ("upper %d bits (of %d bits) is given" % (pbits-kbits, pbits))

PR.<x> = PolynomialRing(Zmod(n))
f = x + pbar
x0 = f.small_roots(X=2^kbits, beta=0.4)[0]  # find root < 2^kbits with factor >= n^0.3
p = x0 + pbar
print(p)
"""
from Crypto.Util.number import *
p = 148500014720728755901835170447203030242113125689825190413979909224639701026120883281188694701625473553602289432755479244507504340127322979884849883842306663453018960250560834067472479033116264539127330613635903666209920113813160301513820286874124210921593865507657148933555053341577090100101684021531775022459
q = n//p
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))

```
### [FSCTF 2023]RSA 1
思路：
已给出p，q，e，直接求d即可
exp：
```bash
from Crypto.Util.number import *

p=1458769258361
q=4556983871563
e=17

d = inverse(e, (p-1)*(q-1))
print(d)
```
### [HUBUCTF 2022 新生赛]baby_encrypt
思路：
根据题目描述，这段数字为某些数字加起来，怀疑ascii码加在一起然后转为字符加起来，手动分割数字后后一位减前一位得到flag每一位的ascii码
exp：
```bash
from Crypto.Util.number import *

m = "0 78 161 244 311 395 465 588 688 740 789 889 945 1044 1144 1201 1257 1359 1407 1455 1553 1603 1651 1703 1804 1861 1917 1965 2013 2070 2127 2183 2284 2383 2485 2541 2593 2643 2698 2799 2924"
m_list  = m.split(" ")
flag = ""
for i in range(1,len(m_list)):
    flag += chr(int(m_list[i])-int(m_list[i-1]))
print(flag)

```
### [MoeCTF 2022]0rsa0
思路：
将flag分为两部分进行加密，第一部分加密e=3，低加密指数加密，第二部分加密为dp泄露
exp：
```bash
n1=……
e1=3
c1=……
n2=……
e2=……
c2=……
dp2=……
import gmpy2
from Crypto.Util.number import *
for i in range(e1):
    m1 = c1+i*n1
    if gmpy2.iroot(m1,3)[1]:
        f1 = long_to_bytes(gmpy2.iroot(m1,3)[0])

for i in range(1,e2):
    if(e2*dp2%i==1):
        p=(e2*dp2-1)//i+1
        if(n2%p!=0):
            continue
        q = n2//p
        phi = (p-1)*(q-1)
        d = inverse(e2,phi)
        m2 = pow(c2,d,n2)
        f2 = long_to_bytes(m2)
print(f1+f2)
```
### [HNCTF 2022 WEEK3]pnearq
思路：
p与q接近，直接分解即可
exp：
```python
from Crypto.Util.number import *
from gmpy2 import *
n = …………
c = …………
e = ……
P309 = ……
P310 = ……
phi = (P309-1)*(P310-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))
```
## 周一
请假
## 周二
### [祥云杯 2022]little little fermat
思路：首先n可以分解，则可以求出m_。再看assert 114514 ** x % p == 1。
可以想到费马小定理![](https://cdn.nlark.com/yuque/__latex/18b4abeb1ca3ff33c20a8c0911551ea3.svg#card=math&code=a%5E%7Bp-1%7D%20%5Cequiv%201%5C%20%28%5C%20mod%5C%20p%29&id=p1v5a)（a为整数）
所以x为p-1
exp：
```python
from Crypto.Util.number import *
import gmpy2
n = 141321067325716426375483506915224930097246865960474155069040176356860707435540270911081589751471783519639996589589495877214497196498978453005154272785048418715013714419926299248566038773669282170912502161620702945933984680880287757862837880474184004082619880793733517191297469980246315623924571332042031367393
c = 81368762831358980348757303940178994718818656679774450300533215016117959412236853310026456227434535301960147956843664862777300751319650636299943068620007067063945453310992828498083556205352025638600643137849563080996797888503027153527315524658003251767187427382796451974118362546507788854349086917112114926883
p = 11887853772894265642834649929578157180848240939084164222334476057487485972806971092902627112665734648016476153593841839977704512156756634066593725142934001
q = 11887853772894265642834649929578157180848240939084164222334476057487485972806971092902627112665734646483980612727952939084061619889139517526028673988305393

phi = (p-1)*(q-1)
d = inverse(65537,phi)
m_ = pow(c,d,n)
x = p -1
print(long_to_bytes(m_ ^ (x**2) ))
```
### [SWPUCTF 2022 新生赛]小明文
思路：
e=3,c也比较小，直接开e次方
exp：
```python
from Crypto.Util.number import *
import gmpy2

c=128198926274489803523728445192921664

e = 3

print(long_to_bytes(gmpy2.iroot(c, e)[0]))
```
### [HNCTF 2022 Week1]XXXOOORRR
思路：
根据异或关系依次异或即可
exp：
```python
from Crypto.Util.number import *

a = 1215421974111272707828609697064234072332368362928440865251897449605952163161176359366553487776268706107760670434157083936287598207881176904763353849369234
b = 10533604054267448009117468094542127075826310122733511023911022436253583775790861879410728001403728088545946257902341417532648419689212361977221573357292618
c = 6401236597601556248960570084212025183497657335932789785351897915858852832577623776212842429736547820800219382515052263929074210010546149322465536545021479
d = 5711309307698496426409561761492698639489294806611133698231840146911562848869711567477706456972659368849642409039245400981517493100724067475248620536111560

a_1 = b^a
a_2 = c^b
m = d ^a_1^a_2
print(long_to_bytes(m))
```
### [MoeCTF 2022]Signin
思路：
e是phi的因数，所以使用AMM算法解题
exp：
```python
import random
import time
from tqdm import tqdm
from Crypto.Util.number import *
# About 3 seconds to run
def AMM(o, r, q):
    start = time.time()
    print('\n----------------------------------------------------------------------------------')
    print('Start to run Adleman-Manders-Miller Root Extraction Method')
    print('Try to find one {:#x}th root of {} modulo {}'.format(r, o, q))
    g = GF(q)
    o = g(o)
    p = g(random.randint(1, q))
    while p ^ ((q-1) // r) == 1:
        p = g(random.randint(1, q))
    print('[+] Find p:{}'.format(p))
    t = 0
    s = q - 1
    while s % r == 0:
        t += 1
        s = s // r
    print('[+] Find s:{}, t:{}'.format(s, t))
    k = 1
    while (k * s + 1) % r != 0:
        k += 1
    alp = (k * s + 1) // r
    print('[+] Find alp:{}'.format(alp))
    a = p ^ (r**(t-1) * s)
    b = o ^ (r*alp - 1)
    c = p ^ s
    h = 1
    for i in range(1, t):
        d = b ^ (r^(t-1-i))
        if d == 1:
            j = 0
        else:
            print('[+] Calculating DLP...')
            j = - discrete_log(d, a)
            print('[+] Finish DLP...')
        b = b * (c^r)^j
        h = h * c^j
        c = c^r
    result = o^alp * h
    end = time.time()
    print("Finished in {} seconds.".format(end - start))
    print('Find one solution: {}'.format(result))
    return result

def onemod(p,r): 
    t=random.randint(2,p)
    while pow(t,(p-1)//r,p)==1: 
         t=random.randint(2,p)
    return pow(t,(p-1)//r,p) 
 
def solution(p,root,e):  
    while True:
        g=onemod(p,e) 
        may=[] 
        for i in tqdm(range(e)): 
            may.append(root*pow(g,i,p)%p)
        if len(may) == len(set(may)):
            return may


def solve_in_subset(ep,p):
    cp = int(pow(c,inverse(int(e//ep),p-1),p))
    com_factors = []
    while GCD(ep,p-1) !=1:
        com_factors.append(GCD(ep,p-1))
        ep //= GCD(ep,p-1)
    com_factors.sort()

    cps = [cp]
    for factor in com_factors:
        mps = []
        for cp in cps:
            mp = AMM(cp, factor, p)
            mps += solution(p,mp,factor)
        cps = mps
    for each in cps:
        assert pow(each,e,p)==c%p
    return cps

e = 65537
p= 12408795636519868275579286477747181009018504169827579387457997229774738126230652970860811085539129972962189443268046963335610845404214331426857155412988073
q= 12190036856294802286447270376342375357864587534233715766210874702670724440751066267168907565322961270655972226761426182258587581206888580394726683112820379
c= 68960610962019321576894097705679955071402844421318149418040507036722717269530195000135979777852568744281930839319120003106023209276898286482202725287026853925179071583797231099755287410760748104635674307266042492611618076506037004587354018148812584502385622631122387857218023049204722123597067641896169655595
n = p*q

m_p = solve_in_subset(1,p)
m_q = solve_in_subset(e,q)

for mpp in m_p:
    for mqq in m_q: 
        m = crt([int(mpp),int(mqq)],[p,q])
        flag = long_to_bytes(m)
        if b'ctf' in flag:
            print(flag)
            break 
```
### [FSCTF 2023]RSA 3
思路：
dp泄露，常规解法
exp：
```python
for x in range(1, e):
	if(e*dp%x==1):
		p=(e*dp-1)//x+1
		if(n%p!=0):
			continue
		q=n//p
		phin=(p-1)*(q-1)
		d=gp.invert(e, phin)
		m=gp.powmod(c, d, n)
		if(len(hex(m)[2:])%2==1):
			continue
		print('--------------')
		print(m)
		print(hex(m)[2:])
		print(bytes.fromhex(hex(m)[2:]))
```
### [LitCTF 2023]baby_xor
思路：
p的低位泄露
exp：
```python
from Crypto.Util.number import *
n = 139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407
c1 = 11201139662236758800406931253538295757259990870588609533820056210585752522925690049252488581929717556881067021381940083808024384402885422258545946243513996
c2 = 112016152270171196606652761990170033221036025260883289104273504703557624964071464062375228351458191745141525003775876044271210498526920529385038130932141551598616579917681815276713386113932345056134302042399379895915706991873687943357627747262597883603999621939794450743982662393955266685255577026078256473601
e = 65537

"""import gmpy2
from tqdm import *

n = 139167681803392690594490403105432649693546256181767408269202101512534988406137879788255103631885736461742577594980136624933914700779445704490217419248411578290305101891222576080645870988658334799437317221565839991979543660824098367011942169305111105129234902517835649895908656770416774539906212596072334423407
c1 = 11201139662236758800406931253538295757259990870588609533820056210585752522925690049252488581929717556881067021381940083808024384402885422258545946243513996
e=65537
pbits = 512
p_high = c1 >> 256
for i in range(2**8):
    p4 = p_high<<8
    p4 = p4 + i
    kbits = pbits - p4.nbits()
    p4 = p4 << kbits
    PR.<x>= PolynomialRing(Zmod(n))
    f = x + p4
    roots = f.small_roots(X=2^kbits, beta=0.4, epsilon=0.01)
    if roots:
        p = p4 + int(roots[0])
        break
print(p)"""
p = 11201139662236758800406931253538295757259990870588609533820056210585752522925662842097418194280333596411677923137891577493678147771013147838272857867768049
q = n//p
phi = (p-1)*(q-1)
d = inverse(e,phi)
print(long_to_bytes(pow(c2,d,n)))
```
### CryptoHack-1-2
思路：
运行给出的脚本即可
exp：
略
### CryptoHack-1-3
思路：
已给出flag的ascii码
exp：
```python
listt = [99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125]
flag = ""
for i in range(len(listt)):
    flag += chr(listt[i])
print(flag)
```
### CryptoHack-1-4
思路：
已给出flag的hex
exp：
```python
strr = "63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d"

print(bytes.fromhex(strr))
```
### CryptoHack-1-5
思路：
已给出hex值，先转为bytes再编码为base64值
exp：
```python
import base64
flag = "72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf"

flag = bytes.fromhex(flag)
flag = base64.b64encode(flag)
print(flag)
```
### CryptoHack-1-6
思路：
已给出long
exp：
```python
from Crypto.Util.number import *
flag = 11515195063862318899931685488813747395775516287289682636499965282714637259206269
print(long_to_bytes(flag))
```
### CryptoHack-1-7
思路：
将给出的字符串和数字异或即可
exp：
```python
string = "label"
flag = ""
for i in string:
    flag += chr(ord(i) ^ 13)
print(flag)
```
### CryptoHack-1-8
思路：
给出xor关系
将hex值先转bytes后再转long
exp：
```python
from Crypto.Util.number import *
a = "a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313"
b = "37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e"
c = "c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1"
d = "04ee9855208a2cd59091d0476Hack
```
### CryptoHack-1-9
思路：
已知flag前几位为”crypto{“
与密文前几位异或得到”\x10“
直接异或即可
### CryptoHack-1-10
思路：
与上题类似，已知flag开头为crypto{
可以先与密文异或得到myXORke，猜测key为myXORkey
然后异或得到flag
exp：
```python
from Crypto.Util.number import *
from pwn import xor
strings = "0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104"
strings = bytes.fromhex(strings)
strings1 = b'crypto{'
key = b''
flag = b''
key = b'myXORkey'
flag = xor(strings,key)
print(flag)
```
### CryptoHack-2-1
思路：
求gcd（a，b）即可
exp：
```python
from Crypto.Util.number import *
a = 66528
b = 52920
print(GCD(a, b))
```
### CryptoHack-2-2
思路：
扩展欧几里得定理
exp：
```python
from Crypto.Util.number import *
from gmpy2 import *
p = 26513
q = 32321
s,s1,s2 = gmpy2.gcdext(p,q)
print(s,s1,s2)
```
### CryptoHack-2-3
思路：
计算即可
exp：
```python
print(11%6)
print(8146798528947%17)
```
### CryptoHack-2-4
思路：
费马小定理
exp：
![](https://cdn.nlark.com/yuque/__latex/18b4abeb1ca3ff33c20a8c0911551ea3.svg#card=math&code=a%5E%7Bp-1%7D%20%5Cequiv%201%5C%20%28%5C%20mod%5C%20p%29&id=ajNMA)
### CryptoHack-2-4
思路：
口算计算逆元
exp：
……
### CryptoHack-2-5
## 周三
NSSCTF刷题
## 周四
请假

